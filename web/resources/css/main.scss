// This is the same as helpers.scale: scale $x from the range l1-h1 to the range
// l2-h2.
@function scale_value($x, $l1, $h1, $l2, $h2) {
  @return calc(($x - $l1) * ($h2 - $l2) / ($h1 - $l1) + $l2);
}

@function scale_clamp_value($x, $l1, $h1, $l2, $h2) {
  @return calc(min($h2, max($l2, scale_value($x, $l1, $h1, $l2, $h2))));
}

// Apply a style while an element is active or hovered.  This handles feedback for both
// desktop and mobile.
//
// Hovering needs an explicit @media check every single time to avoid it being fired in
// nonsensical ways on mobile.
@mixin hover_or_active {
  @media (hover: hover) {
    &:hover {
      @content;
    }
  }

  &:active {
    @content;
  }
}

* {
  // box-sizing: border-box;

  // Prevent drag-to-reload on Android.  This should be the default for home screen apps.
  overscroll-behavior: contain;

  // On mobile, only allow touches to scroll, not to do things like zoom.
  touch-action: pan-x pan-y;

  // Disable images getting highlighted in blue on tap on mobile Chrome.   It would be
  // nicer to use something like a border...
  -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
  -webkit-touch-callout: none;
}

html {
  overflow: hidden;

  // For scrolling to work cleanly on iOS, we need the main scroller to be at the
  // top and not inside an absolute element, or else it gets confused and scrolling
  // randomly gets stuck.
  &.ios {
    // This is a nasty one: when iOS's viewport-fit=cover is used to disable safe
    // zones, height: 100% on the window is wrong and doesn't include the top inset.
    // This isn't needed if we're in landscape, but we don't need to handle that
    // separately since safe-area-inset-top is 0 in landscape.
    height: calc(100% + env(safe-area-inset-top));
  }

  width: calc(100%);
  height: 100%;

  // background-color: var(--main-background-color);
  // background-image: var(--background-noise);

  // Chrome has a lot of bugs around pointer cancellation, and tends to cancel drags when it
  // shouldn't.  Disable drags on the document to partially prevent this.  The document itself
  // doesn't scroll anyway, so this shouldn't matter, but this helps keep things like dialog
  // drags from being cancelled.
  touch-action: none !important;

  // The iOS inset bug also affects absolute positioning.  Set the window to position: relative
  // so absolute positioning is based on the document, so the above workaround affects absolutely
  // positioned nodes too, such as the main screen-illust-container.
  position: relative;

  // iOS's bottom insets are too big, leaving too much space around the pointless navigation line.
  // This can be used to adjust it downwards to a more reasonable amount of padding.
  --fixed-safe-area-inset-bottom: env(safe-area-inset-bottom);

  &.ios {
    --fixed-safe-area-inset-bottom: calc(env(safe-area-inset-bottom) * 0.5);
  }

  // Device-specific styling
  //
  // We handle a few different types of displays, based on data-display-mode.
  //
  // - "normal": The image will fill the screen completely.
  // - "safe": Keep the image entirely in the safe area, not overlapping the status bar
  // if we have one.  It's ugly on white tablets, since it creates an ugly black bar at
  // the top of the screen, but it can be preferable on black tablets where the extra space is
  // mostly invisible.
  // - "notch": We're on a phone with a notch or cutout and we don't want the image to
  // overlap it.  This is similar to safe-area, but only avoids the side we think
  // the notch is on.  This avoids the notch, but not the iOS navigation bar line.
  // In landscape, the notch is on the left or right and the adjustments are rotated accordingly.
  --fullscreen-left: 0;
  --fullscreen-top: 0;
  --fullscreen-right: 0;
  --fullscreen-bottom: 0;

  &[data-display-mode="notch"] {
    &[data-orientation="0"] {
      --fullscreen-top: env(safe-area-inset-top);
    }

    &[data-orientation="90"] {
      --fullscreen-left: env(safe-area-inset-left);
    }

    &[data-orientation="-90"] {
      --fullscreen-right: env(safe-area-inset-right);
    }

    &[data-orientation="180"] {
      --fullscreen-bottom: env(safe-area-inset-bottom);
    }
  }

  &[data-display-mode="safe"] {
    --fullscreen-top: env(safe-area-inset-top);
  }

  // Most notched phones have a rounded edge.  If we just push the image down on these, it
  // gives a square edge at the top and a rounded edge at the bottom, which is ugly and draws
  // visual attention to the empty space at the top.  Rounding the top of the image helps with
  // this: the display is symmetric and the unused area of the screen blends in better.
  //
  // The radius is based on the iPhone 14.  If this is used on other phones, we should probably
  // just let the user set it.
  --device-edge-radius: 0;

  &[data-display-mode="notch"] {
    // Use a relative unit for this, so it's proportional to the device size and not devicePixelRatio.
    // Don't use percentages, since that causes it to become elliptical.
    --device-edge-radius: 14vmin;
  }
}

// Make an element fullscreen.
@mixin fullscreen() {
  position: absolute;
  inset: var(--fullscreen-top) var(--fullscreen-right) var(--fullscreen-bottom) var(--fullscreen-left);
}

// This is a similar backdrop style to iOS Safari's bottom navigation bar.  It doesn't match entirely
// and it may be intentionally not possible to match (it seems to do filter math in linear space with
// browser filters blending in sRGB or vice versa), but it's useful to be a bit different anyway
// so our navigation bar is distinguishable from the browser's.
@mixin overlay-blur() {
  backdrop-filter: blur(15px) contrast(60%) brightness(0.5);
  -webkit-backdrop-filter: blur(15px) contrast(60%) brightness(0.5);
}

// Scrollbar styling.
//
// This is a pain:
// - -webkit-scrollbar isn't a parent of -webkit-scrollbar-thumb, so you can't do
// ::-webkit-scrollbar:hover ::-webkit-scrollbar-thumb to hide the thumb until the
// scrollbar is hidden.
// - The scrollbar doesn't update responsively when we update the thumbnail view when
// this is used.
//
// But, default OS scrollbars are really ugly in a dark theme.  Instead of hiding them entirely,
// we style the thumb to be dark so it mostly blends into the background when it's not in use,
// then set the scrollbar itself to a lighter color on hover, which makes the thumb visible.
// This keeps the scrollbar available, but keeps the slow updates from being visible during normal
// use.  It also keeps the weirdness of the scrollbar updating as we add thumbs from being visible
// (scrollbars as a concept don't mix well with dynamic content).
//
// Disable this on MacOS.  At least in Safari and Chrome on MacOS, the scrollbar is overlaid by
// default (what we want), and if we set scrollbar styles it'll switch to a gutter scrollbar, and
// since Safari doesn't support scrollbar-gutter yet it won't be detected by overlay-scrollbar-tester.
html:not(.macos) {
  // Use a slightly thicker scrollbar for the search results scroller, and set the non-hover color
  // so it blends in with the dark noise background unless it's hovered.
  .search-results {
    &::-webkit-scrollbar {
      width: 10px;
      background-color: rgba(30, 30, 30, 1); // mostly blends in with the dark noise background
    }
  }

  ::-webkit-scrollbar {
    width: 8px;
    background-color: #888;

    &:hover {
      background-color: #888;
    }
  }

  ::-webkit-scrollbar-thumb {
    transition: background-color 0.25s;
    background-color: rgba(0, 0, 0, 1);

    &:hover {
      background-color: #008;
    }

    border: 1px solid rgba(0, 0, 0, 0);
    background-clip: padding-box;
  }

  ::-webkit-resizer {
    background-color: #222;
  }
}

.ppixiv-icon {
  font-family: "ppixiv";
  font-style: normal;
  font-weight: normal;
  font-variant: normal;
  text-transform: none;
  line-height: 1;
  letter-spacing: 0;
  font-feature-settings: "liga";
  -webkit-font-feature-settings: "liga";
  font-variant-ligatures: discretionary-ligatures;
  -webkit-font-variant-ligatures: discretionary-ligatures;
  -webkit-font-smoothing: antialiased;
}

@font-face {
  font-family: "Material Icons";
  font-style: normal;
  font-weight: 400;
  src: url("https://fonts.gstatic.com/s/materialicons/v129/flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2") format("woff2");
}

// We don't use https://fonts.googleapis.com/icon?family=Material+Icons, since it
// rudely sets the font size on the icon, which is a nightmare for actually using the
// icons.
.material-icons {
  font-family: "Material Icons";
  font-weight: normal;
  font-style: normal;
  // font-size: 24px;
  line-height: 1;
  letter-spacing: normal;
  text-transform: none;
  display: inline-block;
  white-space: nowrap;
  word-wrap: normal;
  direction: ltr;
  -webkit-font-smoothing: antialiased;
}

body {
  font-family: "Figtree", sans-serif;
  margin: 0;
  color: #fff;
  height: 100%;
}

a {
  text-decoration: none;
  color: inherit;
}

html.firefox {
  // Firefox only just added support for inert, so explicitly disable pointer events when inert.
  [inert] {
    pointer-events: none !important;

    // Apply this to all lower nodes, so we override other pointer-events rules further down the
    // tree too.
    * {
      pointer-events: none !important;
    }
  }
}

html.mobile {
  // Disable all selection on mobile by default.  It's an endless game of whack-a-mole trying
  // to disable it in the right places.  We can reenable it in specific places where it's wanted
  // if needed.
  * {
    user-select: none;
    -webkit-user-select: none;
  }

  // Disable hover popups on mobile:
  .popup:after {
    display: none !important;
  }

  // Increase the font size on mobile.  Put this on the body and not on the root,
  // so 1rem is still the default font size without this increase.
  > body {
    font-size: 150%;
  }
}

/* Theme colors: */
html {
  // The default size of icons relative to the current text size.  This roughly matches
  // the old icon size.
  --icon-size: 1.7;
  --icon-row-gap: 0.5em;

  &.mobile {
    --icon-size: 3;
    --icon-row-gap: 0.5em;

    // Always use a black background on mobile instead of grey, since it hides notches
    // better.
    --main-background-color: #000;
    --background-noise: none;
  }

  &.mobile [data-hidden-on~="mobile"] {
    display: none !important;
  }

  &.ios {
    [data-hidden-on~="ios"] {
      display: none !important;
    }
  }

  &.android {
    [data-hidden-on~="android"] {
      display: none !important;
    }
  }

  --border-radius-large: 8px;
  --border-radius-small: 4px;
  --main-background-color: #222;
  --background-noise: var(--dark-noise);

  --button-highlight-color: #eee;
  --button-disabled-color: #444;

  // Outlines around text inputs:
  --input-outline: #444;
  --input-outline-focused: #888;

  /* Colors for major UI boxes */
  --ui-bg-color: rgba(0, 0, 0, 0.6);
  --ui-fg-color: #fff;
  --ui-border-color: #63636380;
  --ui-bg-section-color: #3b3b3b;
  /* color for sections within UI, like the description box */

  --ui-bg-blur: blur(20px) brightness(90%) saturate(112%);

  /* Color for frames like popup menus */
  --frame-bg-color: rgba(0, 0, 0, 0.6);
  --frame-fg-color: #fff;
  --frame-border-color: #444;

  --dropdown-menu-hover-color: #444;
  --button-active-bgcolor: #7c7c7c !important;
  --button-bgcolor: #5c5c5c !important;
  --button-color: #fff !important;
  --button-hover-bgcolor: #6e6e6e !important;
  --button-primary-active-bgcolor: #3289cb !important;
  --button-primary-bgcolor: #006cbe !important;
  --button-primary-color: #fff !important;
  --button-primary-hover-bgcolor: #1c7cc5 !important;

  /* Box links used for selection in the search UI: */
  --box-link-fg-color: var(--frame-fg-color);
  --box-link-bg-color: var(--button-bgcolor);
  --box-link-disabled-color: GrayText;
  --box-link-hover-color: var(--button-hover-bgcolor);
  --box-link-selected-color: var(--button-active-bgcolor);
  --box-link-selected-hover-color: var(--button-hover-bgcolor);

  /* Color for the minor text style, eg. the bookmark and like counts.
     * This is smaller text, with a text border applied to make it readable. */
  --minor-text-fg-color: #aaa;
  --minor-text-shadow-color: #000;

  --title-fg-color: #fff;
  /* title strip in image-ui */
  --title-bg-color: #444;

  --like-button-color: #888;
  --like-button-liked-color: #ccc;
  --like-button-hover-color: #fff;

  --context-menu-bg-color: var(--button-bgcolor);
}

[hidden] {
  display: none !important;
}

vv-container {
  display: contents;
}

input,
textarea,
[contenteditable] {
  // Make this consistent, since user agent styles vary.
  padding: 1px 2px;
  font-family: unset;
  font-size: unset;
  background-color: var(--frame-bg-color);
  backdrop-filter: var(--ui-bg-blur);
  color: var(--frame-fg-color);
  border: none;
  outline: 1px solid var(--input-outline);

  &:focus-within {
    outline: 1px solid var(--input-outline-focused);
  }
}

/* Pixiv sometimes displays a random Recaptcha icon in the corner.  It's hard to prevent this since it
 * sometimes loads before we have a chance to stop it.  Try to hide it. */
.grecaptcha-badge {
  display: none !important;
}

.viewer-images {
  // Disable scrolling to prevent pointer events from being cancelled on mobile.
  touch-action: none;

  .image-box {
    position: relative;
    transform-origin: 0 0;
    right: auto;
    bottom: auto;

    > .crop-box {
      position: relative;
      width: 100%;
      height: 100%;
    }
  }

  // If the image is cropped, set overflow: hidden on the image box to cut it
  // off.  Don't do this if it isn't needed, since it can trigger compositing
  // glitches in Chrome.
  .image-box.cropping {
    overflow: hidden;

    // Work around an iOS Safari compositing bug.  If an image is cropped via .crop-box's
    // overflow: hidden, zooming the image leaves cruft from the edge row of the image behind.
    // Setting the image-box to will-change: transform seems to prevent this from happening.
    html.ios & {
      will-change: transform;
    }
  }

  // Let the browser know about our dynamic zooming and panning.  This prevents Chrome from baking the
  // resize when it doesn't change for a while, which causes a big hitch the next time we zoom.
  //
  // Don't do this on iOS, since it has some nasty compositing bugs when this is enabled.
  html:not(.ios) & > .image-box img {
    will-change: transform;
  }

  .displayed-image {
    position: absolute;
    width: 100%;
    height: 100%;

    // Make sure interactions with the image only see the main image, so things like saving
    // images only save the main image.
    &:not(.main-image) {
      pointer-events: none;
    }
  }

  .inpaint-image,
  .low-res-preview {
    pointer-events: none;
  }
}

.viewer-video {
  > .video-container {
    width: 100%;
    height: 100%;
    touch-action: none;
  }

  .top-seek-bar {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 10px;
    pointer-events: none;

    .seek-bar {
      height: 4px;

      > .seek-parts {
        transition: transform 0.25s;
        transform: scale(100%, 0%);
        transform-origin: top;
      }

      &.dragging > .seek-parts {
        transform: scale(100%, 100%) !important;
      }
    }
  }
}

// ppixiv.checkbox_widget:
.checkbox {
  font-size: 150%;
}

// This holds the seek bar and video UI.
.video-ui {
  position: absolute;
  bottom: 0;

  // On mobile, move this above the menu bar.
  html.mobile & {
    bottom: 0;
  }

  left: 0px;
  width: 100%;
  user-select: none;
  -webkit-user-select: none;
  touch-action: none;

  opacity: 0;

  html:not(.mobile) & {
    transition:
      transform 0.25s,
      opacity 0.25s;

    // Visibility:
    // Stay visible if the mouse has moved recently, we're dragging, and while hovering
    // over the UI.
    .mouse-hidden-box.cursor-active &,
    // Visible if the mouse has moved recently
    &.dragging,
    // Visible if we're dragging something in the UI
    &:hover,
    // Visible if we're hovering over the UI
    &.show-ui // Visible if ppixiv.video_ui says so
    {
      opacity: 1;

      .seek-bar[data-position="top"] > .seek-parts {
        transform: scale(100%, 50%);
      }
    }
  }

  // On mobile, we're displayed when the menu is visible and .show-ui is set.  Disable
  // pointer-events if we're not visible.
  html.mobile & {
    // On mobile, use the menu bar's visibility.
    opacity: var(--menu-bar-pos);

    .seek-bar[data-position="top"] > .seek-parts {
      transform: scale(100%, calc(50% * var(--menu-bar-pos)));
    }

    &:not(.show-ui) {
      pointer-events: none;
    }
  }

  .seek-bar {
    height: 12px;

    // If we're above the video UI, add some padding to make the seek bar easier to click.
    // If we're below, don't do this so we're flush against the bottom of the video UI.
    &[data-position="top"] {
      padding-top: 25px;
    }

    // On mobile, add padding above the seek bar to make it easier to drag.
    html.mobile & {
      padding-top: 2em;
    }

    // Hide the seek bar by default.  Show it when the mouse is visible or .visible is set
    // (50% height).  Expand it while dragging (100% height).
    //
    // If the seek bar is at the bottom, disable vertical scaling since we're flush against
    // the bottom of the video UI.
    &[data-position="top"] > .seek-parts {
      transition: transform 0.25s;
      transform: scale(100%, 0%);
      transform-origin: bottom;
    }

    &[data-position="bottom"] {
      // The seek bar is very narrow when below the video UI.  This is only used when in
      // fullscreen, and it's assumed that you can just move the mouse to the bottom of the
      // screen.
      height: 4px;

      // If we're below the video UI, set the empty background to the same as the video UI.
      > .seek-parts > [data-seek-part="empty"] {
        background-color: rgba(0, 0, 0, 0.5);
      }
    }

    // Scale to full size during drags.
    &.dragging > .seek-parts {
      transform: scale(100%, 100%) !important;
    }
  }

  > .video-ui-strip {
    width: 100%;
    padding: 0.25em 1em;
    display: flex;
    flex-direction: row;
    color: #ffffff;
    align-items: center;
    gap: 10px;
    background-color: rgba(0, 0, 0, 0.5);
    cursor: default; // so we don't inherit the video's pointer cursor

    // Tweak the vertical alignment for centering.
    padding-top: 4px;

    .button {
      cursor: pointer;
    }

    .font-icon {
      font-size: 36px;
    }

    > .time {
      font-family: Roboto, Arial, Helvetica, sans-serif;
      font-size: 1.2em;
    }

    .volume-slider {
      display: flex;
      flex-direction: row;
      align-items: center;
      margin-right: -10px;
      padding: 0.5rem 0;
      cursor: pointer;

      > .volume-line {
        height: 0.25rem;
        width: 100px;
      }
    }
  }
}

.seek-bar {
  width: 100%;
  box-sizing: content-box;
  cursor: pointer;
  position: relative;

  > .seek-parts {
    width: 100%;
    height: 100%;

    > [data-seek-part] {
      height: 100%;
      position: absolute;
      left: 0;
      top: 0;
    }

    > [data-seek-part="fill"] {
      background-color: #f00;
    }

    > [data-seek-part="loaded"] {
      background-color: #a00;
    }

    > [data-seek-part="empty"] {
      background-color: rgba(0, 0, 0, 0.25);
      width: 100%;
    }
  }
}

.title-font {
  font-weight: 700;
  font-size: 20px;
  font-family:
    system-ui,
    -apple-system,
    BlinkMacSystemFont,
    Segoe UI,
    Roboto,
    Oxygen,
    Ubuntu,
    Cantarell,
    Droid Sans,
    Helvetica Neue,
    Hiragino Kaku Gothic ProN,
    Meiryo,
    sans-serif;
}

.small-font {
  font-size: 0.8em;
}

// A text box inside a simple frame used for non-interactive messages.
@mixin simple-text-box() {
  display: flex;
  justify-content: center;
  align-items: center;
  user-select: none;
  -webkit-user-select: none;
  margin: 0; //4px 0;
  color: var(--frame-fg-color);
  font-size: 1em;
  pointer-events: none;
  font-size: 1.5rem;

  > .message {
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: var(--border-radius-large);
    overflow: hidden;
    text-align: center;
    max-width: 40em;
    max-height: 50vh; // hard clamp on the height, not normally reached
    padding: 0.25em 0.5em; // inner padding
  }
}

// ppixiv.message_widget
.hover-message {
  @include simple-text-box();

  position: fixed;
  left: max(env(safe-area-inset-left), 1rem);
  right: max(env(safe-area-inset-right), 1rem);

  // illust-menu-visible is set when the mobile navigation bar is visible, and we
  // should nudge this upwards so we don't overlap.
  --extra-distance: 0px;

  html.mobile.illust-menu-visible & {
    --extra-distance: 3em;
  }

  bottom: calc(2vh + env(safe-area-inset-bottom) + var(--extra-distance));
  z-index: 100000;
  /* over everything */

  transition:
    opacity 0.25s,
    bottom 0.25s;
  opacity: 0;

  &.show {
    opacity: 1;
  }
}

.image-ui {
  .disabled {
    display: none;
  }
  .count {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    mix-blend-mode: difference;
  }
  // This is the box that triggers the UI to be displayed.  We use this rather than
  // ui-box for this so we can give it a fixed size.  That way, the UI box won't suddenly
  // appear when changing to another image because a longer description caused the box
  // to become bigger.
  //
  // This is a little tricky.  Hovering over either hover-box or the UI makes it visible.
  // When the UI is hidden, it's set to pointer-events: none, so it can't be hovered,
  // but once you hover over hover-box and cause the UI to be visible, pointer events
  // are reenabled so hovering over anywhere in the UI keeps it visible.  The UI is
  // over hover-box in the Z order, so we don't need to disable pointer events on hover-box
  // to prevent it from blocking the UI.
  //
  // We also disable pointer-events on the UI until it's visible, so it doesn't receive
  // clicks until it's visible.
  .hover-sphere {
    width: 500px;
    height: 500px;

    /* Clamp the sphere to a percentage of the viewport width, so it gets smaller for
        * small windows. */
    max-width: 30vw;
    max-height: 30vw;
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;

    circle {
      pointer-events: auto;
      /* reenable pointer events that are disabled on .ui */
    }

    > svg {
      width: 100%;
      height: 100%;
      transform: translate(-30%);
    }
  }

  .ui-box {
    padding: 8px;
    .button-row {
      width: 70%;
      margin-left: 4px;
      padding-block-end: 8px;
    }
    backdrop-filter: var(--ui-bg-blur);
    position: absolute;
    top: 1vmin;
    left: 1vmin;
    min-width: min(450px, 90vw);
    max-height: min(500px, 100vh - 2vmin);
    width: 30%;

    color: var(--ui-fg-color);
    border: solid 1px var(--ui-border-color);
    background-color: var(--ui-bg-color);
    border-radius: var(--border-radius-large);

    transition:
      transform 0.25s,
      opacity 0.25s;

    overflow-x: hidden;
    overflow-y: overlay;

    opacity: 1;
    transform: translate(0, 0);

    // Hide the UI when ui-hidden is set.  force-ui is used for debugging.
    body:not(.force-ui) &.ui-hidden {
      opacity: 0;
      transform: translate(-50px, 0);
      pointer-events: none;
      user-select: none;
    }

    // The avatar icon in the top-right.  This is absolutely positioned, since we don't
    // want this to push the rest of the UI down.
    .avatar-popup {
      position: absolute;
      width: 4em;
      top: 8px;
      right: 8px;
    }

    .ui-title-box {
      display: flex;
      flex-direction: row;

      // Prevent this from overlapping the absolutely-positioned avatar icon above it.
      margin-right: 4em;
    }

    .post-info {
      padding-inline: 8px;
      padding-block-end: 8px;
    }

    .post-info > * {
      display: inline-block;
      background-color: var(--box-link-bg-color);
      color: var(--box-link-fg-color);
      border-radius: var(--border-radius-large);

      // Use a smaller, heavier font to distinguish these from tags.
      font-size: 0.8em;
      font-weight: bold;
      padding: 8px;
    }

    .post-info > *:hover {
      background-color: var(--box-link-hover-color);
    }

    .description {
      white-space: pre-wrap;
      padding-inline: 8px;
      padding-block: 8px;
      overflow-wrap: break-word;
      border-top: solid 1px var(--ui-border-color);
    }

    .author {
      vertical-align: top;
    }
  }
}

.title-with-button-row-container {
  padding-inline: 1em;
  margin: auto;

  .title-with-button-row {
    display: flex;
    flex-direction: row;
    align-items: start;
  }

  @media (hover: hover) {
    // Limit the title row to one line, and show the full text as an overlay on hover.
    height: 2em;
    overflow: hidden;

    &:hover {
      overflow: visible;

      .title-with-button-row {
        background-color: var(--ui-bg-color);
        position: relative;
        z-index: 1;
      }
    }
  }
}

.image-info-hover-dock {
  max-width: 70%;
  min-height: 3em;
  padding-block-end: 16px;
  padding-inline: 8px;
}

.button-row {
  display: flex;
  flex-wrap: nowrap;
  flex-direction: row;
  overflow: auto;
  align-items: center;
  gap: var(--icon-row-gap);

  .button.enabled {
    cursor: pointer;
  }
}

.icon-button {
  color: var(--button-color);
  cursor: pointer;
  user-select: none;
  -webkit-user-select: none;
  display: block;

  // Set the size of the icon's box to the size the icon will be.  This is the same
  // as setting this element's font-size to 100% * icon-size, but we don't want to change
  // the font size of other things inside the box, like bookmark counts.
  width: calc(1em * var(--icon-size));
  height: calc(1em * var(--icon-size));
  flex-shrink: 0;

  .material-icons,
  .ppixiv-icon {
    display: block;
    font-size: calc(100% * var(--icon-size));
  }

  // If this is an icon-button with an svg inside, set the svg to block.
  svg {
    display: block;
    width: 100%;
    height: 100%;
  }

  @media (hover: hover) {
    &:hover {
      color: var(--button-highlight-color);
    }
  }

  &.highlighted {
    color: var(--button-highlight-color);
  }

  // If a button is directly inside a visible popup menu, eg. the navigation icon:
  .popup-visible > & {
    color: var(--button-highlight-color);
  }

  &.disabled {
    color: var(--button-disabled-color);
  }
}

@media (hover: hover) {
  .disable-ui-button:hover {
    color: #0096fa;
  }
}

.avatar-widget {
  display: block;

  // Set relative so we're the positioning container for the follow dropdown.
  position: relative;

  .avatar {
    transition: filter 0.25s;
    display: block;
    border-radius: var(--border-radius-large);
    object-fit: cover;
    aspect-ratio: 1;
    width: 100%;
    height: 100%;

    @media (hover: hover) {
      &:hover {
        filter: contrast(1.3);
      }
    }
  }

  .follow-icon {
    position: absolute;
    bottom: 5%;
    right: 5%;
    width: 50%;
    /* half the size of the container */
    max-width: 2em;
    /* limit the size for larger avatar displays */
    pointer-events: none;

    > svg {
      display: block;
      width: 100%;
      height: auto;
      transition: opacity 0.25s;

      /* Move the icon down, so the bottom of the eye is along the bottom of the
            * container and the lock (if visible) overlaps. */
      margin-bottom: -20%;
    }

    > svg .middle {
      transition: transform 0.1s ease-in-out;
      transform: translate(0px, -2px);
    }
  }
}

.follow-widget {
  // Allow this to be wide relative to the screen for mobile, but clamp to a reasonable
  // max so long usernames don't expand it indefinitely.
  max-width: min(90vw, 40em);

  .separator {
    height: 2px;
    width: 100%;
    background-color: #fff;
    margin: 2px 0;
  }

  .material-icons {
    margin-right: 8px;
  }
}

.title-block {
  display: inline-block;
  padding: 8px;
  color: var(--title-fg-color);
  margin-right: 1em;

  @media (hover: hover) {
    &.popup:hover:after {
      top: 40px;
      bottom: auto;
    }
  }
}

/* When .dot is set, show images with nearest neighbor filtering. */
body.dot img.filtering,
body.dot canvas.filtering {
  image-rendering: pixelated;
}

/* Override obnoxious colors in descriptions.  Why would you allow this? */
.description * {
  color: var(--ui-fg-color);
}

.popup {
  position: relative;

  @media (hover: hover) {
    &:hover:after {
      pointer-events: none;
      background: #111;
      border-radius: 0.5em;
      top: -2em;
      color: #fff;
      content: attr(data-popup);
      display: block;
      padding: 0.3em 1em;
      position: absolute;
      text-shadow: 0 1px 0 #000;
      white-space: nowrap;
      z-index: 98;
    }

    &[data-popup-side="left"]:hover:after {
      right: 0em;
    }

    &[data-popup-side="right"]:hover:after,
    &:not([data-popup-side]):hover:after {
      left: 0em;
    }

    &.popup-bottom:hover:after {
      top: auto;
      bottom: -2em;
    }
  }
}

body:not(.premium) .premium-only {
  display: none;
}

body:not(.native) .native-only {
  display: none;
}

body:not(.pixiv) .pixiv-only {
  display: none;
}

body.hide-r18 .r18 {
  display: none;
}

body.hide-r18g .r18g {
  display: none;
}

// ppixiv.dropdown_box_opener:
.dropdown-box {
  position: absolute;
  overflow-x: hidden;
  overflow-y: auto;
  border: 1px solid var(--frame-border-color);
  background-color: var(--frame-bg-color);
  border-radius: var(--border-radius-large);
  backdrop-filter: var(--ui-bg-blur);
}

// ppixiv.dropdown_menu_opener:
.popup-menu-box {
  overflow-y: auto;
  min-width: 10em;
  padding: 0.25em 0.25em;
}

.popup-menu-box.hover-menu-box {
  visibility: hidden;
}

.popup-visible .popup-menu-box.hover-menu-box {
  visibility: inherit;
}

/* This is an invisible block underneath the hover zone to keep the hover UI visible. */
.hover-area {
  position: absolute;
  top: -50%;
  left: -33%;
  width: 150%;
  height: 200%;
  z-index: -1;
}

.screen-search-container {
  // The amount of padding at the bottom of the thumbnail scroller to make room for the
  // navigation bar.
  --nav-bar-reserved-height: 1em;

  // The height of the top search bar on mobile.
  --title-height: 0px;

  .search-ui-mobile {
    position: fixed;
    top: 0;
    // The mobile title bar transitions offscreen when not shown.
    translate: 0 calc(var(--title-height) * -1);
    transition:
      translate 0.25s,
      opacity 0.25s;
    opacity: 0;
    font-size: 1.2rem;
    width: 100%;
    z-index: 1;
    padding: 0.5em;
    padding-top: calc(max(0.5em, env(safe-area-inset-top)));
    @include overlay-blur();

    // This box contains the data source UI and disappears when the results box is scrolled
    // down.  Make sure we don't eat too much screen space if the UI is big for some reason
    // and prevent access to scroll the thumbs.
    // max-height: 50vh;
    // overflow-y: auto;

    &.shown {
      translate: 0px 0px;
      opacity: 1;
    }

    .search-title {
      text-align: center;
      display: block;
      max-height: 10vh;
      overflow-y: auto;
    }

    .avatar-widget {
      width: 100px;
    }

    .data-source-ui {
      margin: auto !important;
      padding-inline: 8px;

      // The data source UIs are mostly box-button-rows, sometimes nested inside another
      // box-button-row to indicate where the smaller rows should be wrapped.
      .box,
      -button-row,
      .box-button-row-group {
        justify-content: center;
      }
    }
  }

  .search-title {
    .word {
      padding: 0px 5px;
      vertical-align: middle;

      // Fix the line height so lines with CJK text aren't different from ones that don't, but enough
      // so lines aren't too close together.
      line-height: 1.5em;

      // Parentheses:
      &.paren {
        font-weight: 400;
      }

      &:first-child {
        padding-left: 0px;
        /* remove left padding from the first item */
      }

      &.or {
        font-size: 60%;
        padding: 0;
        color: #bbb;
      }
    }
  }

  // The navigation bar is fixed instead of sticky, since position: sticky gets
  // confused by transforms.
  .mobile-navigation-bar {
    @include overlay-blur();

    html.mobile & {
      padding-top: 0px;
      padding-bottom: env(safe-area-inset-bottom);
    }

    // If we're on mobile and we have no bottom inset, add vertical padding to make the navigation
    // bar easier to tap.  If we do have a bottom inset (eg. we're running standalone on iOS and
    // have the pointless navigation line at the bottom) then the bottom safe area gives us our
    // bottom padding.
    html.mobile:not([data-has-bottom-inset]) & {
      padding-top: 0.75rem;
      padding-bottom: 0.75rem;
    }

    // If we're on mobile and we do have a bottom inset, use the inset as the bottom padding instead
    // of adding our own.  iOS's bottom inset is much too big and leaves a ton of unused space, so
    // reduce it (this is the only device with a bottom inset I'm currently testing on).
    html.mobile[data-has-bottom-inset] & {
      padding-top: 0.5rem;
      padding-bottom: calc(env(safe-area-inset-bottom) * 0.5);
    }

    position: fixed;
    left: 0;
    width: 100%;
    z-index: 1;

    display: flex;
    flex-direction: column;

    --icon-size: 2;
    --button-color: #5a91f7;
    --button-disabled-color: #777;

    // This roughly matches Safari's minimized address bar.
    font-size: 1.2rem;

    transition: bottom 0.25s;
    bottom: calc(var(--nav-bar-height) * -1);

    &.shown {
      // The menu bar should be right at the bottom, but move it down by one pixel to avoid a compositing
      // bug on iOS: the body can render a subpixel outside of the main body of the window, and will bleed
      // through outside of so boxes aligned to top: 0 or bottom: 0.  This will cause it to overlap the
      // iOS blurred navigation bar a bit, but that's not visible since it blurs so much.
      bottom: -1px;
    }

    &:not(.shown) {
      pointer-events: none;
    }

    .header-contents {
      display: flex;
      flex-direction: row;
      justify-content: space-around;
    }
  }

  .search-results {
    // If the nav box is open, shift the search results to make room for it.
    margin-left: var(--navigation-box-reserved-width);
    height: 100%;

    // Make room for system UI, plus the navigation bar at the top on mobile.
    padding-top: calc(env(safe-area-inset-top) + var(--title-height));
    padding-bottom: calc(env(safe-area-inset-bottom));
  }

  .search-desktop-ui {
    // This places the thumbnail UI at the top, so the thumbnails sit below it when
    // scrolled all the way up, and scroll underneath it.
    position: sticky;
    width: 100%;
    display: flex;
    flex-direction: row;
    justify-content: center;
    padding-top: calc(max(1em, env(safe-area-inset-top)));
    padding-bottom: 1em;
    z-index: 1;
    transition: top ease-out 0.2s;

    html:not(.mobile) & {
      // Prevent the empty space around the UI for centering from eating button presses.
      pointer-events: none;

      // Reenable it in its children.
      .thumbnail-ui-box {
        pointer-events: auto;
      }
    }

    &:not(.ui-on-hover) {
      top: 0;
    }

    // If .ui-on-hover is set, switch to showing the top UI when it's hovered instead of sticky.
    &.ui-on-hover {
      // Normally pointer-events is disabled above, so the sides of the UI box don't cover clicks.
      // However, that also makes the hover not include the top padding above the UI, causing it
      // to flicker on and off when the mouse is in that area.  This is tricky to fix nicely, so just
      // stop disabling pointer-events when ui-on-hover is enabled.
      html:not(.mobile) & {
        pointer-events: auto;
      }

      top: 0;

      // .force-open is set to lock the UI in place when a menu is open.  It has the same
      // effect as a hover.
      &:not(.hover):not(.force-open) {
        // --ui-box-height is the current height of this box.
        top: calc(-1 * var(--ui-box-height) + 40px);
      }
    }
  }

  .thumbnail-ui-box {
    display: flex;
    padding: 6px;
    background-color: var(--ui-bg-color);
    backdrop-filter: var(--ui-bg-blur);
    color: var(--ui-fg-color);
    border-radius: var(--border-radius-large);
    box-shadow: 0px 4px 8px 0px rgba(0, 0, 0, 0.32);

    .button-row {
      margin-right: 8px;
    }

    .avatar-container {
      margin: auto;
      position: relative;

      > .avatar-widget {
        float: right;
        height: 64px;
      }
    }

    .image-for-suggestions {
      float: right;
      margin-left: 25px;

      & > img {
        display: block;
        height: 100px;
        width: 100px;
        object-fit: cover;
        object-position: 50% 0;
        border-radius: var(--border-radius-large);
        /* matches the avatar display */
      }
    }

    html[data-whats-new-updated] & .settings-menu-box {
      --button-color: #cc0;
    }
  }

  .following-tag {
    text-decoration: none;
  }
}

.search-results {
  // Always show the scrollbar on the search view, so it doesn't disappear and reappear as
  // we load searches, causing the UI to shift back and forth slightly.
  overflow-y: scroll;
  overflow-x: clip;
  scrollbar-gutter: stable both-edges;
}

.search-view {
  // If the browser is using overlay scrollbars, scrollbar-gutter isn't adding horizontal padding,
  // so we have to add it ourself.  On mobile, allow thumbs to reach the edge of the screen.
  // This padding is outside of .thumbnails so it doesn't confuse makeThumbnailSizingStyle.
  html.has-overlay-scrollbars:not(.mobile) & {
    margin: 0 1em;
  }

  .flash a {
    animation-name: flash-thumbnail;
    animation-duration: 300ms;
    animation-timing-function: ease-out;
    animation-iteration-count: 1;
  }

  @keyframes flash-thumbnail {
    0% {
      filter: brightness(200%);
    }
  }

  > .no-results {
    @include simple-text-box();
    margin-top: 2em;

    > .message {
      padding: 0.5em 1em; // inner padding
    }
  }

  // Marker above the last viewed image:
  .last-viewed-image-marker {
    position: absolute;
    left: 0;
    top: 0;
    pointer-events: none;

    // This is set by makeThumbnailSizingStyle based on the thumbnail size.
    // width: 100px;
    height: auto;

    // Scale the size of the marker to the size of the thumb.
    width: calc(var(--thumb-width) / 4);
  }

  .thumbnail-box:not(.flash) .last-viewed-image-marker {
    display: none;
  }

  .thumbnail-box.expanded-thumb a.thumbnail-link {
    border-radius: var(--border-radius-large);
  }

  // A vertical strip of thumbnail rows:
  .thumbnails {
    user-select: none;
    -webkit-user-select: none;
    text-align: center;
    row-gap: var(--thumb-padding);
    width: var(--container-width);
    display: flex;
    flex-direction: column;
    padding-bottom: var(--thumb-padding);

    // Center thumbs if they don't fill the screen.
    margin: 0 auto;

    .row {
      display: flex;
      flex-direction: row;
      column-gap: var(--thumb-padding);
      align-items: flex-end;
      justify-content: center;
    }

    /* Add a stroke around the heart on thumbnails for visibility.  Don't
         * change the black lock. */
    .button-bookmark svg > .heart {
      stroke: #000;
      stroke-width: 0.5px;
    }
  }

  // content-visibility is broken on iOS and causes thumbs to not be displayed.
  html:not(.ios) & .row {
    content-visibility: auto;
    contain-intrinsic-height: var(--row-height);
    contain: strict;
  }

  .thumbnail-box {
    position: relative;
    width: var(--thumb-width);
    height: var(--thumb-height);
    flex-shrink: 0;

    .thumb {
      object-fit: cover;

      /* Show the top-center of the thumbnail.  This generally makes more sense
            * than cropping the center. */
      object-position: 50% 0%;
      width: 100%;
      height: 100%;
    }

    /* Hide pending images (they haven't been set up yet). */
    &[data-pending] {
      visibility: hidden;
    }

    a.thumbnail-link {
      display: block;
      width: 100%;
      height: 100%;

      html:not(.mobile) & {
        border-radius: var(--border-radius-large);
        overflow: hidden;
      }
    }

    // Thumbnail animations aren't used on mobile.  Avoid defining it if we're not using it,
    // so we don't put transforms on thumbnails and possibly cause more complicated compositing.
    @media (hover: hover) {
      // Thumbnail zooming
      //
      // If thumbnail zooming is enabled, zoom thumbs in while not hovered.
      --zoom-thumb: 1;

      body:not(.disable-thumbnail-zooming) &:not(:hover) {
        --zoom-thumb: 1.25;
      }

      .thumb {
        transition: transform 0.5s;
        transform: scale(var(--zoom-thumb));
      }

      // Thumbnail panning
      //
      // Pause panning animations while the mouse isn't over them.
      --pan-thumb: paused;

      body:not(.disable-thumbnail-panning) &:hover {
        --pan-thumb: running;
      }
    }

    &.muted {
      .muted-text {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;

        display: flex;
        flex-direction: column;
        justify-content: center;
        pointer-events: none;

        color: #fff;

        .muted-icon {
          opacity: 0.8;
          display: block;
          font-size: calc(min(var(--thumb-height) * 0.25, 3rem));
          //font-size: 4rem;
        }

        .muted-label {
          font-size: 1rem;
        }
      }

      // Crop off the blur.  Don't always crop thumbs, since it causes a delay on iOS
      // every time thumbs scroll in.
      overflow: hidden;

      // Zoom muted images in a little, and zoom them out on hover, which is the opposite
      // of other images.
      .thumb {
        filter: blur(5px) grayscale(0.2) brightness(0.3);
        transform: scale(1.25, 1.25);
      }

      body:not(.disable-thumbnail-zooming) & .thumb:hover {
        transform: scale(1, 1);
      }
    }

    &:not(.muted) .muted-text {
      display: none;
    }

    @media (hover: hover) {
      // Hide the manga page button beyond the first page when not hovering.
      &.expanded-manga-post:not(:hover):not(.first-manga-page) .manga-info-box {
        display: none;
      }
    }

    .bottom-row {
      position: absolute;
      display: flex;
      align-items: end;
      justify-content: center;

      // Slight padding between the icons and the text.  Note that this is applied even
      // if there's no icon, and it's applied to the empty flexes between the items, so
      // this is very small.
      gap: 4px;
      pointer-events: none;
      width: 100%;
      max-height: 75%;
      bottom: 3px;
      padding: 0 4px;
      overflow: hidden;

      // Reduce the font size to the default on mobile.
      html.mobile & {
        font-size: 1rem;
      }

      // These are tricky.  We want the label to be centered, and if icons are shown in the
      // corners, the label stays centered as long as there's room.  It only shifts or shrinks
      // if we run out of space.  Give the boxes for icons an equal width and an extremely large
      // flex-shrink.  The boxes will try to be the same size if there's nothing inside them, so
      // they'll shrink by the same amount, and the huge flex-shrink will cause them to shrink
      // completely to make room for the label as needed.  If an icon is shown inside them the
      // box will have a minimum size and not shrink past that, but the shrinking will still
      // happen evenly until it reaches that size.
      .bottom-left-icon,
      .bottom-right-icon {
        height: 32px;
        width: 100px;
        flex-shrink: 100000;
        display: flex;
        align-items: center;
        gap: 0.25em;
        justify-content: end;
        align-self: end;
      }

      .bottom-right-icon {
        margin-right: 8px;
      }

      .thumbnail-label {
        display: flex;
        align-items: center;

        // Align to the top, so if it's cropped to max-height we see the top of the text.
        align-self: start;

        gap: 0.5em;
        flex-shrink: 1;
        color: var(--frame-fg-color);
        background-color: rgba(0, 0, 0, 0.6);
        padding: 4px 8px;
        overflow: hidden;
        border-radius: 6px;

        .thumbnail-ellipsis-box {
          text-overflow: ellipsis;
          overflow: hidden;

          & > .label {
            /* Specify a line-height explicitly, so vertical centering is reasonably consistent for
                         * both EN and JP text. */
            line-height: 19px;
          }
        }

        .ugoira-icon {
          color: #fff;
        }
      }

      .heart {
        width: 32px;
        height: 32px;
      }

      .manga-info-box {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        vertical-align: middle;
        padding: 0.25em 0.5em;
        background-color: rgba(0, 0, 0, 0.6);
        border-radius: var(--border-radius-small) !important;
        white-space: nowrap;
        cursor: pointer;
        overflow: hidden; // clip the hover background-color to our border radius

        // Clicks inside here are too small and finicky for mobile and get in the way of trying
        // to click the thumbnail itself.
        html:not(.mobile) & {
          pointer-events: auto; // turn pointer events back on
        }

        &:hover {
          background-color: rgba(0, 20, 120, 0.8);
        }

        &:hover .regular {
          display: none;
        }

        &:not(:hover) .hover {
          display: none;
        }

        .page-count {
          vertical-align: middle;
          padding-left: 0.15em;

          // Chop off descenders.
          html:not(.ios) & {
            margin-bottom: -0.15em;
          }
        }

        html.mobile &.show-expanded {
          .page-icon {
            display: none;
          }

          .page-count {
            padding-left: 0;
            margin-bottom: 0;
          }
        }
      }

      .ai-image {
        height: 100%;
        object-fit: contain;
        padding: 4px;
        image-rendering: pixelated;
      }
    }
  }

  @media (hover: hover) {
    .thumbnail-box:hover {
      .heart > svg,
      .ugoira-icon,
      .ai-image {
        opacity: 0.5;
      }
    }
  }

  [data-type="order-shuffle"] .icon {
    font-size: 24px;
  }

  .artist-header {
    // This should line up with the thumbnail columns exactly.
    display: flex;
    flex-direction: column;
    align-items: center;
    width: var(--container-width);
    padding-bottom: var(--thumb-padding);
    margin: 0 auto;
    user-select: none;
    -webkit-user-select: none;

    // This node surrounds the image and gives it its rounding.  This is separate from the image
    // so we can hide the image and show a temporary color while the image loads.
    .shape {
      width: 100%;

      // Cap the header height to the size of thumbs, so if thumbnails are very small we
      // scale the header down with them.
      height: min(20vh, var(--row-height));

      overflow: hidden;
      background-color: #333;

      html:not(.mobile) & {
        border-radius: var(--border-radius-large);
      }

      img.bg {
        width: 100%;
        height: 100%;
        object-fit: cover;
        object-position: 50% 100%;

        &.loaded {
          object-position: 50% 20%;
        }

        // Settle lower if we're not animating.
        &.loaded:not(.animated) {
          object-position: 50% 40%;
        }

        &.animated {
          transition: object-position ease 5s;
        }
      }
    }
  }
}

// A row of box-links inside a menu row.  This is used for menu items that have
// secondary buttons, like the public and private bookmark search buttons.  For
// these the main box-link doesn't stretch to fill the row, so it's easy to tell
// what button you're pressing, and the extra buttons are flush right.
.box-link-row {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 0.5em;

  // Note that the padding on box-links here matches the horizontal padding
  // on .vertical-list .box-link.
  > .box-link {
    margin-right: 0.5em;
    padding-inline: 0.5em;
  }
}

// box-links in horizontal strips.  Add horizontal padding between these.
.box-button-row {
  display: flex;
  flex-direction: row;
  flex-wrap: unwrap;
  overflow: auto;
  align-items: center;
  row-gap: 0.5em; // space between lines if we wrap

  // Center these on mobile, but keep them left-aligned on desktop.
  html.mobile & {
    justify-content: center;
  }

  // A .box-button-row.group is a group of box-button-rows.  This is used to encourage
  // the browser to wrap between groups instead of within them if possible, and we put
  // a bit more padding between groups to differentiate them.  We can still put buttons
  // directly inside these groups too.
  &.group {
    column-gap: 1em;
  }

  > .box-link {
    margin: 0 0.25em; // horizontal spacing between buttons
    padding: 0 0.5em; // horizontal padding within the button

    // Place vertical padding on the contents rather than the box, so clicks are always
    // within one of the items and not on the small vertical padding around it.
    //
    // For box links that are just <a class=box-link>text</a>, the vertical padding is added
    // in the a.box-link rule.
    & > * {
      padding: 0.25em 0;
    }
  }
}

// box-links that are in a horizontal strip have vertical padding outside the box, to
// space them apart.  box-links that are in a vertical dropdown menu have their vertical
// padding inside the button, so there's no empty space between menu items.  The total
// padding stays the same.
.vertical-list {
  // The default background color on box-links is there to indicate that it's a button.  Remove it
  // when a box is nothing but a stack of box-links.
  --box-link-bg-color: rgba(0, 0, 0, 0);

  user-select: none;
  -webkit-user-select: none;

  // For box-links directly within the list (most of them), put the horizontal
  // padding on them.
  > .box-link {
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  > .box-link {
    display: flex;
    flex-direction: row;
    align-items: center;

    margin-top: 0;
    margin-bottom: 0;
  }
}

.box-link:hover {
  background-color: var(--box-link-hover-color);
}

.box-link {
  border-radius: var(--border-radius-large);
  display: inline-flex;
  cursor: pointer;
  text-decoration: none;
  margin: 0;
  padding: 0 0.75em;
  align-content: center;
  align-items: center;
  height: 2em;

  // Make sure CJK fonts don't extend the label beyond our 2em height when padding is
  // added.
  line-height: 1.5em;
  color: var(--box-link-fg-color);
  user-select: none;
  -webkit-user-select: none;
  background-color: var(--box-link-bg-color);

  .label-box {
    flex: 1;
    display: flex;
    align-items: center;
  }

  .label {
    // This is so the label text aligns correctly with .icon .material-icons.
    vertical-align: middle;
    flex: 1;
    // white-space: nowrap;
  }

  &:not(.allow-wrap) {
    white-space: nowrap;
  }

  &.selected {
    background-color: var(--box-link-selected-color);
  }

  &:not(.disabled) {
    @include hover_or_active {
      background-color: var(--box-link-hover-color);

      &.selected {
        background-color: var(--box-link-selected-hover-color);
      }
    }
  }

  &.disabled {
    color: var(--box-link-disabled-color);
    cursor: auto;

    // Also prevent disabled links from showing an unfilled URL:
    pointer-events: none;
  }

  &.tag {
    /* Some tags are way too long, since translations don't put any sanity limit on length.
         * Cut these off so they don't break the layout. */
    max-width: 100%;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  // An icon on the left side.
  .icon {
    display: inline-block;
    // position: relative;

    // If this is a material icon, .material-icons will try to change the font size, which
    // is rude.  Override it to inherit the current font size.
    font-size: inherit;
    vertical-align: middle;

    // .icon.with-text is an icon that has a label next to it, which is most of them.  If .with-text
    // isn't set, this is an icon-only button, like the shuffle button.
    &.with-text {
      margin-right: 0.25em;

      // Force the width to 1ch, so the icon takes up space even if it's empty.  This keeps labels
      // in lists  aligned if some items have icons and some don't.  If there should be no space at
      // all, the icon will be hidden.
      width: 1ch;
    }

    &:not(.with-text) {
      // There's no text, so increase the size of the icon to fill the button better.
      font-size: 150%;
    }
  }
}

.search-box {
  display: flex;
}

// This holds the search box, and positions the search dropdowns beneath it.
.tag-search-box {
  display: flex;
  flex-wrap: wrap; // for mobile
  align-items: center;
  position: relative;
  gap: 0.5em;

  > .search-history {
    position: absolute;
    left: 0;
    bottom: 0;
  }
}

.input-field-container {
  flex: 1;
  padding: 6px 10px;

  outline: 1px solid var(--input-outline);

  &:focus-within {
    outline: 1px solid var(--input-outline-focused);
  }

  display: inline-flex;
  gap: 0.5em;
  align-items: center;

  > input {
    outline: none;
    font-size: 1.2em;
    vertical-align: middle;
    flex: 1;

    // Remove the default min-width.
    min-width: 0;

    // For some reason we have to set a small width to allow this input to flex, otherwise
    // it still gets a minimum width which is much too wide for mobile.
    // width: 1px;
  }

  // Buttons to the right of the input box:
  > .right-side-button {
    display: flex;
    font-size: 150%;
    vertical-align: middle;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;

    &.disabled {
      color: #888;
    }
  }
}

/* Search box in the menu: */
.navigation-search-box {
  .search-submit-button {
    vertical-align: middle;
    margin-left: -30px;
    /* overlap the search box */
  }

  input.search-tags {
    width: 100%;
    padding-right: 30px;
    /* extra space for the submit button */
  }
}

.viewer-error {
  .muted-image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    filter: blur(20px);
    opacity: 0.75;
  }

  .error-text-container {
    position: absolute;
    width: 100%;
    top: 50%;
    left: 0;
    text-align: center;
    font-size: 30px;
    color: #000;
    text-shadow:
      0px 1px 1px #fff,
      0px -1px 1px #fff,
      1px 0px 1px #fff,
      -1px 0px 1px #fff;
  }
}

.tag-list.box-button-row.widget {
  padding-block-end: 12px;
  margin: 0 8px 0 4px;
}

.data-source-tag-list {
  max-height: 50vh;

  // Try to set a minimum width, but clamp at the viewport width, so we fill horizontally
  // if we're on desktop and filling the screen.
  min-width: min(20em, 100vw);
  max-width: 100vw;
  overflow-x: hidden;
  overflow-y: auto;
  white-space: nowrap;

  // If this tag is marked as having been searched for recently, highlight it.
  // This is used in the artist data source.
  .recent {
    --box-link-bg-color: #550;
    --box-link-hover-color: #660;
  }

  // Adjust the popup for the tag lists so they don't cover the tag.
  .tag-entry:hover:after {
    left: auto;
    right: 0px;
  }
}

// The search edit and search history boxes:
.input-dropdown {
  user-select: none;
  -webkit-user-select: none;
  resize: horizontal;
  width: var(--width); // set by script
  max-width: min(800px, 100vw);

  // Hide edit buttons when not editing.
  &:not(.editing) {
    .edit-button,
    .editing-only {
      display: none !important;
    }
  }

  .edit-button,
  .group-suggestions-button {
    align-items: center;
    justify-content: center;
    border: 1px solid #bbb;
    height: 1.5em;
    width: 1.5em;
    cursor: pointer;
    display: flex;

    &.selected {
      color: #000;
      background-color: #ccc;
    }

    @media (hover: hover) {
      &:hover {
        border-color: #fff;
      }
    }
  }

  &.loading {
    pointer-events: none;
    opacity: 0;
  }

  .input-dropdown-list {
    margin: 1px;

    display: flex;
    flex-direction: column;
    white-space: normal;

    // Add some padding on the on the right of the scrollbar for clarity.
    margin-right: 3px;

    // Only show edit buttons like delete on user sections, not built-in ones.
    .tag-section:not(.user-section) .user-section-edit-button {
      display: none !important;
    }

    // Hide the delete button for autocomplete.
    .tag-section.autocomplete .delete-entry {
      display: none !important;
    }

    .tag-section {
      position: sticky;
      top: 0;
      width: 100%;
      display: flex;
      gap: 0.5em;
      align-items: center;
      background-color: #001a44;
      padding: 0.5em 1em;
      margin-bottom: 5px;
      cursor: pointer;
      line-height: 1.5em;

      .label,
      .label-edit {
        flex: 1;
      }
    }

    // When editing, reduce the padding on the section headers to match the other rows, so
    // the buttons line up.
    &.editing .tag-section {
      padding: 0.5em;
    }

    .entry {
      display: flex;
      flex-direction: row;
      color: var(--box-link-fg-color);
      align-items: center;
      gap: 0.5em;
      padding: 0.5em;
      border-radius: var(--border-radius-large);

      // Show edit buttons in the modes specified in data-shown-in.
      &.recent .edit-button[data-shown-in~="recent"] {
        display: flex;
      }

      &.saved .edit-button[data-shown-in~="saved"] {
        display: flex;
      }

      &.autocomplete .edit-button[data-shown-in~="autocomplete"] {
        display: flex;
      }

      .edit-button {
        display: none;
      }

      .search {
        flex: 1;
        height: 100%;
        display: inline-flex;
        flex-direction: row;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.5em;
      }

      .search .word {
        display: inline-flex;
        align-items: center;
        height: 100%;
        line-height: 1em;

        &.or {
          font-size: 12px;
          color: #aaa;
        }
      }

      &.selected {
        background-color: var(--box-link-selected-color);
      }
    }

    // Only highlight on hover when editing is disabled, since activating entries is disabled
    // during editing.
    &:not(.editing) .entry {
      @media (hover: hover) {
        &:hover {
          background-color: var(--box-link-hover-color);
        }

        &:hover.selected {
          background-color: var(--box-link-selected-hover-color);
        }
      }
    }

    // Disable the pointer cursor on the search links while editing.
    &.editing .entry {
      cursor: default;
    }
  }
}

.widget.hidden-widget {
  display: none;
}

/* The right click context menu for the image view: */
#popup-context-menu {
  color: #fff;
  position: fixed;
  text-align: left;
  padding: 4px;
  border: 1px solid var(--ui-border-color);
  border-radius: var(--border-radius-large);
  background-color: var(--ui-bg-color);
  backdrop-filter: var(--ui-bg-blur);
  z-index: 10;
  user-select: none;
  -webkit-user-select: none;
  will-change: opacity, transform;
  transition:
    opacity ease 0.15s,
    transform ease 0.15s;

  // Most of this can just scale based on the size of the button, but we need to set the icon
  // size directly.
  --button-size: 32px;
  --button-size-small: 22px;

  // Override the default hidden-widget hiding behavior.
  &.hidden-widget {
    display: inherit;
    opacity: 0;
    pointer-events: none;
    transform: scale(0.85);
  }

  &:not(.hidden-widget) {
    opacity: 1;
  }

  /* Hide the normal tooltips.  The context menu shows them differently. */
  & .popup:hover:after {
    display: none;
  }

  // Set the avatar icon to the same size as the other popup menu buttons.
  .avatar-widget {
    transition: filter 0.25s;
    display: block;
    position: relative;
    height: inherit;
    filter: contrast(1);
  }

  .inline-tooltip {
    margin-top: 4px;
    font-size: 11px;
    color: #ccc;
    text-align: center;
    white-space: nowrap;
    pointer-events: none;
    user-select: none;
  }

  .context-menu-item {
    display: flex;
    border-radius: var(--border-radius-small);
    height: var(--button-size);
    padding-inline: 8px;
    align-items: center;
    gap: 4px;
  }

  .context-menu-item:hover {
    background-color: var(--button-hover-bgcolor);
  }

  .tooltip-display {
    position: fixed;
    pointer-events: none;
    background: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 9999;

    .tooltip-display-text {
      display: inline;
      background-color: var(--frame-bg-color);
      color: var(--frame-fg-color);
      padding: 2px 8px;
      border-radius: var(--border-radius-large);
      white-space: nowrap;

      &:after {
        content: attr(data-popup);
      }
    }
  }

  #context-menu-buttons-group {
    display: grid;
    max-height: 500px;
    gap: 2px;

    > .button-block {
      display: inline-flex;
      flex-direction: column;
      background-color: var(--context-menu-bg-color);
      padding: 12px;

      box-sizing: content-box;
      justify-content: stretch;
      align-items: center;
    }

    /* Remove the double horizontal padding: */
    & > .button-block:not(:first-child) {
      padding-left: 0px;
    }

    /* Remove the double vertical padding.  Do this with a negative margin instead of zeroing
         * the padding, so the rounded black background stays the same size. */
    &:not(:last-child) > .button-block {
      margin-bottom: -12px;
    }
    .context-menu-item-description {
      display: block;
      font-size: 0.8em;
      width: inherit;
    }

    .ctx-icon {
    }

    .count {
      color: white;
      text-shadow:
        0px 1px 1px var(--minor-text-shadow-color),
        0px -1px 1px var(--minor-text-shadow-color),
        1px 0px 1px var(--minor-text-shadow-color),
        -1px 0px 1px var(--minor-text-shadow-color);
      font-size: 0.7em;
      font-weight: bold;
      width: 100%;
      text-align: center;
      position: absolute;
      top: -4px;
      left: -8px;
    }

    svg {
      height: var(--button-size-small);
      width: var(--button-size-small);
    }

    .button-zoom-level,
    .button-browser-back,
    .button-zoom-level svg {
      margin-right: 4px;
    }

    .button {
      height: var(--button-size);
      cursor: pointer;
      display: flex;

      .font-icon {
        font-size: var(--button-size-small);
        margin-right: 4px;
      }

      /* Grey out the buttons if this strip isn't enabled. */
      &:not(.enabled) {
        cursor: inherit;
        color: #666;
      }

      @media (hover: hover) {
        &.enabled:hover {
          color: #fff;
          background-color: var(--button-hover-bgcolor);
        }
      }

      &.enabled.selected {
        background-color: var(--button-hover-bgcolor);
        color: #fff;
      }

      /* We don't have a way to add classes to inlined SVGs yet, so for now just use nth-child.
               The first child is the + icon and the second child is -. */
      &.button-zoom:not(.selected) > :nth-child(1) {
        display: none;
      }

      &.button-zoom.selected > :nth-child(2) {
        display: none;
      }

      /* Popup menu bookmarking */
      .tag-dropdown-arrow {
        width: 0;
        height: 0;
        border-top: 10px solid #222;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
      }
    }

    // size + left padding + right padding
    > .button-block.shift-right {
      margin-left: calc(var(--button-size) + 12px + 12px);
    }

    > .button-block.shift-left {
      margin-left: calc(-1 * (var(--button-size) + 12px + 12px));
    }
  }

  #context-menu-image-info-container {
    // Bottom align within the row.
    align-self: flex-end;
    background-color: var(--context-menu-bg-color);
    padding-right: 8px;

    // Mobile Chrome sometimes randomly selects this text while it's hidden, causing
    // the translation popup to appear.
    user-select: none;
    -webkit-user-select: none;
  }

  #context-menu-image-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }

  .popup-bookmark-tag-dropdown {
    // Nudge the dropdown to the left by the width of a button-block
    // when it's inside the popup menu.
    right: -100%;
  }
}

.popup-more-options-container {
  .button-send-image {
    svg .arrow {
      transition: transform ease-in-out 0.15s;
    }

    &:not(.disabled):hover svg .arrow {
      transform: translate(2px, -2px);
    }
  }
}

.bookmark-tag-list,
.more-options-dropdown {
  /* In the context menu version, nudge the tag dropdown up slightly to cover
     * the rounded corners. */
  #popup-context-menu & {
    top: calc(100% - 4px);
  }

  > .tag-list {
    min-width: 200px;
  }

  /* Recent bookmark tags in the popup menu: */
  .popup-bookmark-tag-entry {
    display: flex;
    flex-direction: row;
    align-items: center;
    padding: 0.25em 0.5em;
    cursor: pointer;

    > .tag-name {
      flex: 1;
      display: flex;
      gap: 0.5em;
    }

    background-color: var(--box-link-bg-color);

    &.selected {
      background-color: var(--box-link-selected-color);
    }

    @media (hover: hover) {
      &:hover {
        background-color: var(--box-link-hover-color);

        &.selected {
          background-color: var(--box-link-selected-hover-color);
        }
      }
    }
  }
}

.mobile-illust-ui-dialog {
  --box-link-bg-color: none;
}

.mobile-illust-ui-container {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;

  // This node is for positioning and covers the whole screen, so don't eat pointer events.
  pointer-events: none;

  --pointer-events: none;

  &.fully-visible {
    --pointer-events: auto;
  }

  // Use a very slightly transparent black for the frame, and disable the box link background so it
  // just uses the frame background.
  // --frame-bg-color: #111;
  --frame-bg-color: rgba(0, 0, 0, 0.65);
  --box-link-bg-color: none;

  .mobile-illust-ui-page {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: stretch;

    user-select: none;
    -webkit-user-select: none;

    translate: 0 #{scale_value(var(--menu-bar-pos), 0, 1, var(--menu-bar-height), 0px)};

    .avatar {
      align-self: center;
    }

    .avatar-widget {
      opacity: var(--menu-bar-pos);
      pointer-events: var(--pointer-events);
      margin-bottom: 1em;
      width: min(170px, 50vmin);

      > .avatar {
        // Don't use a box-shadow here, since it causes stuttering during the transition.
        border: 1px solid #000;
      }

      .follow-icon {
        bottom: 0;
        right: 0;
      }
    }

    .menu-bar {
      opacity: var(--menu-bar-pos);
      pointer-events: var(--pointer-events);

      // Note that the background color extends into the top safe area, so if we're overlapping
      // a statusbar (safe-area mode), we'll dim under the statusbar so the menu isn't floating.
      padding-top: 0.5em;
      padding-bottom: calc(max(env(safe-area-inset-bottom), 0.5em));
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);

      // This controls the icon size.
      font-size: 65%;

      display: flex;
      flex-direction: row;
      justify-content: space-evenly;
    }
  }

  .item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25em;
    padding: 0 0.25em;
    justify-content: center;

    // Grey out the button and label if this item isn't enabled.
    --foreground-color: #aaa;

    &.enabled {
      --foreground-color: #fff;
    }

    &.selected {
      --foreground-color: #ff8;
    }

    color: var(--foreground-color);

    & > svg {
      width: 2em;
      height: 2em;
    }

    .label {
      text-align: center;

      // This font size is extremely small, but matches the styling used for iOS tabs.
      font-size: 0.7rem;
    }

    /* Popup menu bookmarking */
    .tag-dropdown-arrow {
      width: 0;
      height: 0;
      border-top: 10px solid #222;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
    }

    .font-icon {
      font-size: 200%;
    }
  }
}

// The background and padding for the tag list goes on the individual tags.
.mobile-image-info {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;

  .author-block {
    display: inline-flex;
    align-items: center;

    .avatar-widget {
      height: inherit;
      margin-right: 0.5em;
    }
  }

  .description {
    display: inline-block;
    width: 100%;
    background-color: #000;
    padding: 8px;
    border: 1px solid #aaa;
    overflow-wrap: break-word;
  }

  .bookmark-tags {
    margin-top: 0.25em;
    display: flex;
    flex-wrap: wrap;
    flex-direction: row;
    gap: 0.25em 0.5em;
    justify-content: center;

    .mobile-ui-tag-entry {
      // Only wrap between tags, not in the middle.
      white-space: nowrap;
      background-color: var(--frame-bg-color);
      padding: 0.5em 0.75em;
      border-radius: var(--border-radius-large);
      line-height: 1.5em;
      flex: 1;

      .bookmark-tag-icon {
        vertical-align: middle;
      }
    }
  }
}

.button-bookmark,
.button-like {
  position: relative;
}

/* Hide the "delete" stroke over the heart icon unless clicking the button will
 * remove the bookmark. */
svg.heart-image .delete {
  display: none;
}

.button-bookmark {
  // Bookmark buttons.  These appear in image_ui and the popup menu.
  @media (hover: hover) {
    &.button.will-delete.enabled:hover svg.heart-image .delete {
      display: inline;
    }
  }

  @media (hover: hover) {
    &.enabled:hover svg {
      color: #f00 !important;
      stroke: none;
    }
  }
}

.button.button-like {
  /* This is a pain due to transition bugs in Firefox.  It doesn't like having
     * transition: transform on both an SVG and on individual paths inside the
     * SVG and clips the image incorrectly during the animation.  Work around this
     * by only placing transitions on the paths. */
  & > svg {
    color: var(--like-button-color);
  }

  &.liked > svg {
    color: var(--like-button-liked-color);
  }

  @media (hover: hover) {
    &.enabled:hover > svg {
      color: var(--like-button-hover-color);
    }
  }
}

.button.button-browser-back {
  .arrow {
    transition: transform ease-in-out 0.15s;
    transform: translate(-2px, 0px);
  }

  @media (hover: hover) {
    &:hover .arrow {
      transform: translate(1px, 0px);
    }
  }
}

.button.button-like {
  --overall-translate-x: 0;
  --overall-translate-y: 0;
  --mouth-scale-x: 1;
  --mouth-scale-y: 0.75;
  --mouth-translate-x: 0;
  --mouth-translate-y: 0;

  &.liked {
    --mouth-scale-x: 1;
    --mouth-scale-y: 1.1;
    --mouth-translate-x: 0;
    --mouth-translate-y: -3px;
    --overall-translate-x: 0;
    --overall-translate-y: -3px;
  }

  @media (hover: hover) {
    &.enabled:hover {
      --overall-translate-x: 0;
      --overall-translate-y: -2px;
      --mouth-scale-x: 1;
      --mouth-scale-y: 0.9;
      --mouth-translate-x: 0;
      --mouth-translate-y: -3px;
    }
  }

  > svg {
    > * {
      transition: transform ease-in-out 0.15s;
      transform: translate(var(--overall-translate-x), var(--overall-translate-y));
    }

    > .mouth {
      transform: scale(var(--mouth-scale-x), var(--mouth-scale-y))
        translate(var(--mouth-translate-x), var(--mouth-translate-y));
    }
  }
}

.button-bookmark.public svg.heart-image .lock {
  display: none;
}

.button-bookmark svg.heart-image .lock {
  stroke: #888;
}

@mixin general-dialog(
  // $type is either "normal" or "small".  A normal dialog is a large one, like the settings
  // dialog.  A small one is something like a confirmation popup.  Small popups are always floating.
  // Normal popups are floating except on a phone, where it fills the screen.  We know whether
  // we're small or normal at compile time ($type), but we have to use a media query to see if
  // we're treating the device as a phone.
  $type: "normal",

  // If true, darken the background more than default.  This is used for dialogs like settings
  // which have more brightness variation and darkening the background more is useful for
  // readability.
  $dark: false
) {
  // The top-level container-container sits outside the dialog.  This fills the screen and handles dimming
  // the background.
  position: fixed;
  z-index: 1000;
  inset: 0;
  overscroll-behavior: contain;

  // On iOS, push the dialog out vertically by one pixel to work around Safari compositing bugs
  // that leave a row of pixels not covered properly.
  html.ios & {
    inset: -1px 0;
  }

  // This is set by the dialog transition.
  --dialog-visible: 1;

  // We've set padding for the absolute maximum dialog size.  If the dialog decides to be
  // smaller, floating dialogs are centered vertically and regular dialogs are bottom-aligned.
  display: flex;
  align-items: flex-end;

  &.floating {
    align-items: center;
  }

  justify-content: center;

  // --dialog-backdrop-alpha is the color around the dialog to dim what's underneath it.
  // --dialog-bg-alpha is the background of the dialog itself.  In fullscreen, put the dialog
  // background on the container, so we can transition it separately from the dialog animation.
  // Note that these overlap, and --dialog-bg-alpha will be applied on top of --dialog-backdrop-alpha.
  &:not(.floating) {
    // total brightness .25: (1-0.5) * (1-0.5)
    --dialog-bg-alpha: 0.5;
    --dialog-backdrop-alpha: 0.5;
  }

  &.floating {
    // total brightness .125: (1-0.5) * (1-0.75)
    --dialog-bg-alpha: 0.75;
    --dialog-backdrop-alpha: 0.5;
  }

  --dialog-bg-color: rgba(0, 0, 0, var(--dialog-bg-alpha));
  background-color: rgba(0, 0, 0, #{scale_clamp_value(var(--dialog-visible), 0, 1, 0, var(--dialog-backdrop-alpha))});

  // We increase the global font size on mobile, but it's too much for dialogs.  Set it to
  // a smaller multiplier.
  html.mobile & {
    font-size: 1.2rem;
  }

  // The minimum horizontal padding around non-fullscreen dialog content.
  --edge-padding-inner-horiz: 20px;
  --edge-padding-inner-vert: 20px;

  html.mobile & {
    --edge-padding-inner-horiz: 10px;
    --edge-padding-inner-vert: 10px;
  }

  --edge-padding-outer-horiz: 40px;
  --edge-padding-outer-vert: 20px;

  // If this is a floating dialog, also apply edge padding inside the dialog.
  &.floating {
    // Most of the time, the safe area is in the outer padding.
    --dialog-outer-padding-left: calc(max(env(safe-area-inset-left), var(--edge-padding-outer-horiz)));
    --dialog-outer-padding-right: calc(max(env(safe-area-inset-right), var(--edge-padding-outer-horiz)));
    --dialog-outer-padding-top: calc(max(env(safe-area-inset-top), var(--edge-padding-outer-vert)));
    --dialog-outer-padding-bottom: calc(max(var(--fixed-safe-area-inset-bottom), var(--edge-padding-outer-vert)));

    --dialog-inner-padding-left: var(--edge-padding-inner-horiz);
    --dialog-inner-padding-right: var(--edge-padding-inner-horiz);
    --dialog-inner-padding-top: var(--edge-padding-inner-vert);
    --dialog-inner-padding-bottom: var(--edge-padding-inner-vert);

    // Floating dialogs fade in and out, since they don't pan all the way offscreen.
    .dialog {
      opacity: scale_clamp_value(var(--dialog-visible), 0, 1, 0, 1);
    }
  }

  &:not(.floating) {
    --edge-padding-horiz: 20px;
    --edge-padding-vert: 20px;
    --dialog-extra-top-padding: 2vh;

    // For fullscreen dialogs, leave a small amount of padding at the top to indicate that this
    // can be dragged down to close, and include the top inset in this padding.  The rest of the
    // dialog is flush against the edge of the screen, so put the rest of the padding in the
    // inner padding.
    --dialog-outer-padding-left: 0px;
    --dialog-outer-padding-right: 0px;
    --dialog-outer-padding-top: calc(env(safe-area-inset-top) + var(--dialog-extra-top-padding));
    --dialog-outer-padding-bottom: 0px;

    --dialog-inner-padding-left: calc(max(env(safe-area-inset-left), var(--edge-padding-inner-horiz)));
    --dialog-inner-padding-right: calc(max(env(safe-area-inset-right), var(--edge-padding-inner-horiz)));
    --dialog-inner-padding-top: var(--edge-padding-inner-vert);
    --dialog-inner-padding-bottom: calc(max(var(--fixed-safe-area-inset-bottom), var(--edge-padding-inner-vert)));

    // Round the top of fullscreen dialogs.
    .dialog {
      border-radius: var(--border-radius-large);
      overflow: hidden;
    }
  }

  // There are two places we can put padding: inside the dialog itself (--dialog-inner-padding),
  // and outside the dialog (dialog-outer-padding).  We only have outer padding if we're floating.
  //
  // We have two types of padding: padding to make sure the contents aren't flush against the
  // edge, and safe area padding.  Put these in CSS vars, so the dialog instance can put them
  // somewhere else if wanted.  For example, if a dialog scrolls, we might want the inner padding
  // inside the scroller.
  padding: var(--dialog-outer-padding-top) var(--dialog-outer-padding-right) var(--dialog-outer-padding-bottom)
    var(--dialog-outer-padding-left);

  > .dialog {
    padding: var(--dialog-inner-padding-top) var(--dialog-inner-padding-right) var(--dialog-inner-padding-bottom)
      var(--dialog-inner-padding-left);

    //--dialog-transform-distance
    transform: translateY(#{scale_value(var(--dialog-visible), 0, 1, 100%, 0%)});

    // .dialog > .scroll is for optional scrolling content.  Dialogs with fixed content
    // don't need to use this.
    .scroll {
      overflow-x: hidden;
      overflow-y: auto;
      touch-action: pan-y;

      // .dialog has the inner padding for everything inside the dialog, but if we have
      // a scroller, we want the scrollbar to be flush with the edge.  Do this by reversing
      // the horizontal padding with a negative margin and then re-adding it with padding so
      // the contents stay padded.  We also do this on the bottom, so text can flow all the
      // way to the bottom and past any UI decorations and the padding is on the content.
      // Don't do this on top, since it won't take the header into account.
      margin-right: calc(var(--dialog-inner-padding-right) * -1);
      padding-right: calc(var(--dialog-inner-padding-right));
      margin-left: calc(var(--dialog-inner-padding-left) * -1);
      padding-left: calc(var(--dialog-inner-padding-left));
      margin-bottom: calc(var(--dialog-inner-padding-bottom) * -1);
      padding-bottom: calc(var(--dialog-inner-padding-bottom));
      // margin-top: calc(var(--dialog-inner-padding-top) * -1);
      // padding-top: calc(var(--dialog-inner-padding-top));
    }
  }

  // For floating dialogs, set a maximum width so they aren't too wide on wide screens, a
  // minimum width so layout doesn't break if the window is tiny, and cap the size at 90%
  // of the window.
  &.floating .dialog {
    min-width: 20em;
    max-width: min(45em, 90vw);

    // The dialog scales vertically to fill its content, but on desktop, don't go beyond
    // 90% of the window height so we leave some space on the top and bottom.
    max-height: 90vh;

    border-radius: var(--border-radius-large);
  }

  &.small .dialog {
    // Small popups just size to fit their content.
    min-width: 10em;
    max-width: 45em;
  }

  // Fullscreen dialogs flex to their height up to the maximum, and stretch to fill horizontally.
  &:not(.floating) .dialog {
    width: 100%;
  }

  .dialog {
    max-height: 100%;
    border: solid 1px var(--ui-border-color);
    border-radius: var(--border-radius-large);
    background-color: var(--ui-bg-color);
    backdrop-filter: var(--ui-bg-blur);
    color: var(--ui-fg-color);
    position: relative;
    display: flex;
    flex-direction: column;
  }

  &.dragging-dialog {
    > .dialog {
      // Disable inputs during drags.  For example, this prevents bookmark tag buttons from being
      // triggered by short drags in the mobile bookmark dialog.  Do this inside .dialog and not
      // on the top level container, or buttons underneath the dialog can be activated by the drag.
      pointer-events: none;
    }

    // Disable all vertical scrollers inside dialogs while dragging horizontally to close.  This prevents
    // vertical movement in the scroller once the horizontal dragger has taken over the drag, and prevents
    // the dragger from being cancelled by the scroller on Android.
    //
    // This includes nested scrollers, like the individual panels in the settings dialog.
    .vertical-scroller {
      overflow: hidden !important;
    }
  }

  .header {
    --icon-size: 2;

    line-height: 2em;
    display: flex;
    align-items: center;

    // This container flexes to center the title.  The button itself is separate, so the
    // flex area isn't part of the close button.
    .close-button-container {
      flex: 1;

      .close-button {
        --icon-size: 1.5;
        color: var(--button-color);
        cursor: pointer;
        justify-self: center;

        @media (hover: hover) {
          &:hover {
            color: var(--button-highlight-color);
          }
        }

        & > svg {
          display: block;
        }
      }
    }

    .header-text {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-weight: 600;
    }

    // This has the same size as close-button to center header-text, but shrink if it needs
    // more space.
    .center-header-helper {
      // --icon-size is 2em each, plus the 1em padding-right on the icon:
      width: calc(1em * var(--icon-size) + 1em);
      flex: 1;
      flex-shrink: 100000;
    }
  }
}

.dialog-normal {
  @include general-dialog($type: "normal");
}

.dialog-small {
  @include general-dialog($type: "small");
}

// A dialog that just contains a single button:
.simple-button-dialog {
  @include general-dialog($type: "small");
  background: #0004;

  .dialog {
    padding: 0;
    background: none;
    --box-link-bg-color: #0004;
    --box-link-hover-color: #0008;

    .box-link {
      padding: 1.5em 2em;
    }
  }
}

.whats-new-dialog {
  display: flex;
  flex-direction: column;

  .font-icon {
    vertical-align: bottom;
  }

  .rev {
    display: inline-block;
    color: var(--box-link-fg-color);
    background-color: var(--box-link-bg-color);
    padding: 5px 10px;
  }

  .text {
    margin: 1em 0;
    padding: 0 20px;
    /* inset horizontally a bit */
  }

  .explanation-button {
    cursor: pointer;
    text-decoration: underline;
  }

  .explanation-target {
    margin: 0 1em;
  }
}

.mobile-tag-list {
  @include general-dialog();
  --box-link-bg-color: none;

  > .dialog {
    // The bottom inner padding is moved into menu-bar, so its backdrop filter reaches the edge.
    padding-bottom: 0;

    > .scroll {
      // Remove the padding on the bottom, so the menu bar sits on the bottom and
      // the text isn't visible underneath it in the padding.
      margin-bottom: 0;
      padding-bottom: 0;
    }
  }

  .popup-bookmark-tag-entry {
    font-size: 120%;

    // Set a min width on the tag list, so it isn't very thin if the tags are all
    // short.  The actual size will be capped by the dialog.
    min-width: 20em;
  }

  .menu-bar {
    --icon-size: 1.6;
    position: sticky;
    bottom: 0;
    display: flex;
    flex-direction: row;
    justify-content: space-evenly;
    align-items: center;

    // Don't use em here, since that results in fractional pixels, which causes the backdrop-filter
    // to not reach the edge on Chrome.
    padding: 8px 0;
    padding-bottom: var(--dialog-inner-padding-bottom);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }
}

.text-entry-popup {
  @include general-dialog($type: "small");

  .header {
    font-size: 20px;
  }

  .input-box {
    position: relative;
    display: flex;
    align-items: center;

    > .editor {
      flex: 1;
      padding: 4px;
      min-width: min(50vw, 25em);
      white-space: pre-wrap; // don't cut off whitespace
    }

    > .submit-button {
      cursor: pointer;
      display: flex;
      margin-left: 6px;
      padding: 0.25em;
      border: 1px solid white;
    }

    @media (hover: hover) {
      > .submit-button:hover {
        background-color: #444;
      }
    }
  }
}

.confirm-dialog {
  @include general-dialog($type: "small");

  .scroll {
    display: flex;
    flex-direction: column;
    align-items: center;

    .text {
      text-align: center;
      padding: 1em 0;
    }

    .input-box {
      display: flex;
      align-items: center;
      gap: 2em;
    }
  }
}

// The top-level container for screen_illust.  This sits on top of the search view, fills
// the screen and clears the background to hide the search view.
.screen-illust-container {
  // The top-level container fills the screen completely.  This needs to be fixed and not
  // absolute, so it doesn't scroll with the body, which is still scrolled to the search
  // view's position.
  position: fixed;
  inset: 0;

  // This screen doesn't have a background color, so we don't obscure the search view
  // during transitions.  We just use the document's background.
  //background-color: var(--main-background-color);
  //background-image: var(--background-noise);

  // Make sure we're on top of the search view.  Without this, the sticky UI header will be
  // above the illust view.
  z-index: 1;

  // This is animated by screen_illust.  At 0, screen_illust is displayed, and at 1, screen_search
  // is displayed.  Since it's owned by screen_illust, give it a default of hidden, so screen_search
  // is visible if screen_illust hasn't made itself visible yet.
  --illust-hidden: 1;

  // The view container holds the actual viewers, and applies safe zones and the rounded
  // edge effect if they're being used.
  .view-container {
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;

    // Move up by the height of the menu bar when it's visible.  This follows the transition of the
    // bar.
    translate: 0px calc(var(--menu-bar-pos) * var(--menu-bar-height) * -1);

    // The individual image viewers.  There's usually just one of these, but we can have
    // multiple for transitions.
    .viewer {
      @include fullscreen();

      // Hide viewers by making them invisible instead of not displayed, so viewers have dimensions
      // while they're setting up for setting things like the initial pan/zoom position.
      &.hidden-widget {
        display: unset;
        visibility: hidden;
        pointer-events: none;
      }
    }
  }

  .fade-search {
    position: fixed;
    z-index: -1;

    // Extend through any browser overlays, even if they're not included in safe zone offsets.
    inset: -100vh;
    pointer-events: none;

    // Fade the background to black when we're active.
    background-color: rgba(0, 0, 0, scale_value(var(--illust-hidden), 0.1, 1, 1, 0));
  }

  // Transitions for the viewer.  Don't move the container itself, since the background
  // fade shouldn't move with the image.
  .view-container {
    // Crop outside of the container, so viewers don't scroll in over notches when in
    // landscape.
    position: absolute;
    overflow: hidden;
    inset: 0;

    transform: translateX(calc(var(--illust-hidden) * var(--animation-x)))
      translateY(calc(var(--illust-hidden) * var(--animation-y)))
      scale(scale_value(var(--illust-hidden), 0, 1, 1, var(--animation-scale)));
    transform-origin: 0% 0%;

    // illust-hidden is 0 when we want to be visible and 1 when we want to be transparent.
    // We actually stay fully visible until it reaches 0.7, so we only start fading out near
    // the end of the animation.  This results in opacity values outside the 0-1 range, which
    // will just be clipped.
    opacity: scale_value(var(--illust-hidden), 0, 1, 1, 0);

    // If enabled, round the top edge of the element to match the screen dimensions.
    html.mobile & .viewer .rounded-box {
      overflow: hidden;

      // This can be set to adjust the amount of rounding.
      --rounding-amount: 1;

      border-radius: var(--border-radius-large);

      // Work around border-radius not clipping contents when transform is animated on iOS.
      // This makes the browser create a composite layer for this container.
      will-change: transform;
    }
  }

  .manga-page-indicator {
    position: absolute;
    bottom: 0px;
    --width: min(50%, 400px);
    left: calc((100% - var(--width)) / 2);
    right: calc((100% - var(--width)) / 2);
    height: 10px;
    z-index: 1;
    pointer-events: none;
    box-sizing: content-box;
    border: 1px solid #000;
    border-bottom: none;
    border-radius: var(--border-radius-large);
    overflow: hidden;
    opacity: 0;

    // This bright but mostly transparent background makes the fill visible
    // on dark backgrounds where the black border isn't visible, but doesn't
    // have much effect on bright backgrounds where the border can be seen.
    background-color: rgba(255, 255, 255, 0.25);

    .bar {
      position: absolute;
      inset: 0;

      background: linear-gradient(to right, rgba(255, 20, 20, 0.75) var(--percent), rgba(50, 50, 50, 0) var(--percent));
    }
  }

  .page-change-indicator {
    position: absolute;
    height: 100%;
    display: flex;
    align-items: center;
    pointer-events: none;

    &[data-side="left"] {
      margin-left: 20px;
      left: 0;
    }

    &[data-side="right"] {
      margin-right: 20px;
      right: 0;
    }

    &[data-side="right"] svg {
      transform-origin: center center;
      transform: scale(-1, 1);
    }

    /* Hide the | portion of >| when showing last page rather than end of results. */
    &[data-icon="last-page"] svg .bar {
      display: none;
    }

    svg {
      opacity: 0;
    }

    &.flash svg {
      animation: flash-page-change-opacity 400ms ease-out 1 forwards;
    }

    &.flash svg .animated {
      animation: flash-page-change-part 300ms ease-out 1 forwards;
    }
  }

  @keyframes flash-page-change-opacity {
    0% {
      opacity: 1;
    }

    40% {
      opacity: 1;
    }

    80% {
      opacity: 0;
    }
  }

  @keyframes flash-page-change-part {
    0% {
      transform: translate(0, 0px);
    }

    20% {
      transform: translate(-4px, 0px);
    }

    100% {
      transform: translate(0, 0px);
    }
  }

  .translation-status {
    position: absolute;
    left: 2rem;
    bottom: 2rem;
    pointer-events: none;

    // Show this widget while ImageTranslations has set data-loading-translation.
    transition: opacity 0.25s;

    html[data-loading-translation] & {
      opacity: 1;
    }

    opacity: 0;

    .translation-contents {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.5rem;
      font-size: 2rem;
      background-color: #4040a0;
      border-radius: 100%;
    }
  }
}

.link-tab-popup {
  .explanation {
    max-width: 25em;
    width: 100%;
    text-align: center;
    margin: 0 auto;
  }

  .button {
    display: inline-block;
    cursor: pointer;
    background-color: #000;
    padding: 0.5em 1em;
    margin: 0.5em;
    border-radius: var(--border-radius-large);
  }

  .content {
    width: 400px;
    padding: 1em;
  }

  .buttons {
    display: flex;
  }

  .tutorial-monitor {
    width: 290px;
    height: 125px;

    // This SVG has padding on the bottom so the rotating monitor doesn't get clipped as
    // it turns.  Remove some of that for layout.
    margin-bottom: -20px;

    .rotating-monitor {
      transform-origin: 75px 30px;
      // transform: rotate(90deg);
      animation: rotate-monitor 4500ms linear infinite;

      @keyframes rotate-monitor {
        0% {
          transform: rotate(0deg);
        }

        10% {
          transform: rotate(90deg);
        }

        50% {
          transform: rotate(90deg);
        }

        60% {
          transform: rotate(0deg);
        }
      }
    }
  }
}

.years-ago {
  padding: 0.25em;
  margin: 0.25em;
  white-space: nowrap;

  /* These links are mostly the same as box-link, but since the
     * menu background is the same as the box-link background color,
     * shift it a little to make it clear these are buttons. */
  > a {
    padding: 4px 10px;
    background-color: #444;
  }
}

.tree {
  user-select: none;
  -webkit-user-select: none;
  overflow-x: hidden;
  overflow-y: auto;
  flex: 1;

  .tree-item {
    position: relative;

    // Items can use content-visibility if they have no children, which makes the list
    // much faster when there are a lot of items.  If an item has expanded children then
    // the parent container doesn't have a fixed height since the children nodes are part
    // of the parent, so this is only enabled for non-expanded items.
    contain-intrinsic-height: 32px;

    &.allow-content-visibility {
      content-visibility: auto;
    }

    // If this isn't the root node, add padding to the left of our children.
    &:not(.root-item) > .items {
      margin-left: 1em;
    }

    &.selected > .self > .label {
      background-color: #003088;
    }

    > .self {
      display: flex;
      flex-direction: row;
      align-items: center;
      height: 2em;

      &:focus {
        // Hide the default focus outline.
        outline: none;
      }

      > .label {
        // This padding matches .tree-popup > .label.
        padding: 0.5em;
        white-space: nowrap;
      }

      &.root-item {
        display: none;
      }

      > .expander {
        display: flex;
        justify-content: center;
        align-items: center;

        font-size: 50%;
        width: 3em;
        height: 100%;

        & > .expander-button {
          // Hide all buttons by default.
          display: none;
          width: 3em;
          text-align: center;
          vertical-align: middle;
        }

        // Modes are "none", "loading", "expandable" and "expanded".
        &[data-mode="loading"] > .loading {
          display: block;
        }

        &[data-mode="none"] > .none {
          display: block;
        }

        // Dim pending expanders.
        &[data-pending="true"] > .expand {
          opacity: 0.5;
        }

        &[data-mode="expandable"] > .expand,
        &[data-mode="expanded"] > .expand {
          display: block;
        }

        .expand {
          transform: rotate(0deg);
          transition: transform 0.25s;
        }

        &[data-mode="expanded"] > .expand {
          transform: rotate(90deg);
        }
      }
    }
  }
}

.screen-search-container {
  --navigation-box-width: 25%;
  --navigation-box-reserved-width: var(--navigation-box-width);

  // If we're not showing navigation, don't reserve space for it.  Don't change the actual
  // nav box's size, so we can transition it in and out cleanly.
  &:not([data-show-navigation]) {
    --navigation-box-reserved-width: 0%;
  }

  height: 100%;
}

.local-navigation-box {
  height: 100vh;
  width: var(--navigation-box-width);
  position: fixed;
  top: 0;
  left: 0;
  background-color: #111;
  border-right: solid 1px #444;
  padding-top: 0.5em;
  padding-left: 0.5em;
  opacity: 1;
  transition:
    opacity 0.35s,
    transform 0.35s;
  display: flex;
  flex-direction: column;

  .screen-search-container:not([data-show-navigation]) & {
    opacity: 0;
    pointer-events: none;
    transform: translate(-50%, 0);
  }
}

.tree-popup {
  background-color: #222;
  color: #fff;
  position: fixed;
  pointer-events: none;
  outline-style: dotted;
  outline-width: 1px;
  outline-color: #aaa;

  > .label {
    // This padding matches .tree .label.
    // padding: 0.5em;
    white-space: nowrap;
  }
}

.thumb-popup {
  position: fixed;
  pointer-events: none;
  margin-left: 10px;
  width: 25%;
  height: 40%;
  max-height: 400px;
  max-width: 400px;

  > img {
    object-fit: contain;
    width: 100%;
    height: 100%;
  }
}

@mixin settings-dialog() {
  @include general-dialog($dark: true);
  // Set the font size.  This ignores the font size multiplier we use for the rest
  // of the UI on mobile, which is much too big for settings, and is slightly larger
  // on desktop.
  font-size: 1.15rem;

  // Try to set a fixed minimum size, so the dialog doesn't resize when the page is
  // changed, but allow it to go lower if the screen is very small.  Don't do this
  // if the dialog is fullscreen.
  &.floating .dialog {
    min-height: calc(min(30em, 100%));
    width: 100%; // use the maximum
  }

  &.phone {
    .scroll {
      justify-content: center;
    }
  }

  // The section selector on the left side of the settings dialog:
  .sections {
    white-space: nowrap;
    display: flex;
    flex-direction: column;
    overflow-y: auto;

    > .box-link {
      padding: 0.5em;
      cursor: pointer;

      &:not(.selected) {
        opacity: 0.65;
      }

      &:not(.active) {
        background: none;
      }

      @media (hover: hover) {
        &:hover {
          background-color: var(--box-link-hover-color);
        }
      }
    }

    html[data-whats-new-updated] & .settings-page-button[data-page="whatsNew"] {
      color: #ff0;
    }
  }

  // Note that this matches items in the side-by-side view, but not in the mobile
  // fullscreen view.
  > .dialog > .scroll > .items {
    flex: 1;

    // Scroller for the individual settings pages.  This isn't needed if we're fullscreen in phone,
    // since the scroller is on the dialog,
    overflow-y: auto;
  }

  .settings-list {
    display: flex;
    flex-direction: column;
    height: 100%;

    .settings-row {
      padding: 0.5em;
    }

    .box-link {
      // Disable some regular box-link styles:
      height: auto;
      align-items: stretch;
      flex-direction: column;
      --box-link-bg-color: #00000000;

      // Extra buttons (the linked tabs "edit" button):
      > .buttons > .box-link {
        padding: 0.35em 0.75em;
      }

      // If this isn't a clickable row, such as a slider, disable effects on hover.
      &:not(.clickable):hover {
        cursor: inherit;
        background: none;
      }
    }

    > .box-link {
      > .label-box {
        .label {
          flex: 1;
        }
      }

      > .explanation {
        font-size: 80%;
        color: #ccc;
      }
    }
  }
}

.settings-dialog {
  @include settings-dialog();

  html.mobile & {
    // Space out the top-level page a bit more on mobile, and flex so the whole column
    // is clickable and not just the text.
    .sections {
      gap: 0.5em;
    }

    // If we're not floating, the section list is being displayed on its own.  Flex it
    // so the whole column is clickable and not just the text.  Don't do this in the
    // split section/page view since it makes the labels bigger.
    &:not(.floating) .sections {
      flex: 1;
    }
  }

  > .dialog > .scroll {
    // Put the page buttons and the page side-by-side.
    display: flex;
    flex-direction: row;

    // Spacing between the page buttons and the content on the right:
    gap: 2em;
  }
}

.settings-dialog-page {
  @include settings-dialog();
}

.edit-search-dialog {
  @include general-dialog();

  .scroll {
    display: flex;
    flex-direction: column;
    height: 100%;

    .navigation-button {
      font-size: 1.25em;

      --box-link-bg-color: none;

      // Prevent long buttons (artist names in particular) from overflowing.
      overflow: hidden;
    }
  }
}

.muted-tags-popup {
  padding: 0.5em 1em;
  display: flex;
  flex-direction: column;
  gap: 0.5em;
  overflow-y: auto;
}

.edit-post-mute-dialog,
.muted-tags-popup {
  .mute-warning {
    border: solid 2px black;
    border-radius: var(--border-radius-large);
    background-color: #000;
    padding: 1em;
  }

  .add-muted-user-box {
    .font-icon {
      font-size: 24px;
      vertical-align: middle;
    }
  }

  .non-premium-mute-warning {
    // For the edit tags dialog, prevent the button from overlapping the dialog
    // close button.
    margin-right: 40px;

    .icon {
      font-size: 24px;
      color: #ffff00;
    }
  }

  .post-mute-list {
    display: flex;
    flex-direction: column;
    gap: 4px;

    .entry {
      display: flex;
      align-items: center;
      gap: 0.5em;

      &.muted .tag-name {
        color: #ffaaaa;
      }
    }
  }

  .mute-list .remove-mute .font-icon {
    font-size: 24px;
    vertical-align: middle;
  }
}

.image-editor {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1; // above the image
  pointer-events: none;

  &.temporarily-hidden {
    display: none;
    pointer-events: none;
  }

  .save-edits.dirty {
    color: #0f0;
  }

  .spinner .icon {
    animation: spin 1000ms linear infinite forwards;
  }

  .image-editor-buttons {
    // Hide the top buttons if the window doesn't have focus.
    body:not(.focused) &.top {
      display: none;
    }

    &.top {
      top: 0.5em;
    }

    &.bottom {
      bottom: 0.5em;
    }

    position: absolute;
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    font-size: 150%;
    width: 100%;
    align-items: flex-start;

    > .left {
      margin-right: auto;
    }

    > .center {
      grid-column-start: 2;
    }

    > .right {
      margin-left: auto;
    }

    .image-editor-button-row {
      pointer-events: auto;
    }

    .block-button {
      .font-icon {
        display: block;
      }
    }
  }

  @keyframes spin {
    0% {
      transform: rotate(0);
    }

    100% {
      transform: rotate(360deg);
    }
  }
}

.crop-editor-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;

  .crop-box {
    position: relative;

    // This sets how far the handles overlap into the middle area.
    --overlap: 1vh;

    [data-crop="all"] {
      // A large box shadow around the middle area to dim the image:
      box-shadow: 0px 0px 0px 10000px #00000080;
    }

    &[data-mode="crop"] [data-crop="all"] {
      outline: 3px solid #fff;
      outline-style: ridge;
    }

    &[data-mode="safe_zone"] [data-crop="all"] {
      // Use a different outline style in this mode as a visual cue for which mode you're in.
      outline: 1px solid #fff;
      outline-offset: 1px;

      // When editing the safe zone, dragging the middle moves the image instead of the rect, so
      // it's easier to move the view around.
      pointer-events: none;
    }

    .handle {
      position: absolute;

      &[data-crop="top"] {
        cursor: n-resize !important;
      }

      &[data-crop="left"] {
        cursor: w-resize !important;
      }

      &[data-crop="right"] {
        cursor: e-resize !important;
      }

      &[data-crop="bottom"] {
        cursor: s-resize !important;
      }

      &[data-crop="topleft"] {
        cursor: nw-resize !important;
      }

      &[data-crop="topright"] {
        cursor: ne-resize !important;
      }

      &[data-crop="bottomleft"] {
        cursor: sw-resize !important;
      }

      &[data-crop="bottomright"] {
        cursor: se-resize !important;
      }

      &[data-crop="all"] {
        cursor: move !important;
      }

      // Handle positions:
      &[data-crop="top"] {
        width: 100%;
        height: 10000px;
        bottom: calc(100% - var(--overlap));
      }

      &[data-crop="left"] {
        width: 10000px;
        height: 100%;
        right: calc(100% - var(--overlap));
      }

      &[data-crop="right"] {
        width: 10000px;
        height: 100%;
        left: calc(100% - var(--overlap));
      }

      &[data-crop="bottom"] {
        width: 100%;
        height: 10000px;
        top: calc(100% - var(--overlap));
      }

      &[data-crop="topleft"] {
        width: 10000px;
        height: 10000px;
        right: calc(100% - var(--overlap));
        bottom: calc(100% - var(--overlap));
      }

      &[data-crop="topright"] {
        width: 10000px;
        height: 10000px;
        bottom: calc(100% - var(--overlap));
        left: calc(100% - var(--overlap));
      }

      &[data-crop="bottomleft"] {
        width: 10000px;
        height: 10000px;
        top: calc(100% - var(--overlap));
        right: calc(100% - var(--overlap));
      }

      &[data-crop="bottomright"] {
        width: 10000px;
        height: 10000px;
        top: calc(100% - var(--overlap));
        left: calc(100% - var(--overlap));
      }

      &[data-crop="all"] {
        width: 100%;
        height: 100%;
        left: 0;
      }
    }
  }
}

.inpaint-editor-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;

  &.creating-lines {
    cursor: crosshair !important;
  }

  .inpaint-segment {
    // inpaint-editor-overlay disables pointer-events.  Turn it back on here.
    pointer-events: auto;
    .inpaint-line {
      fill: none;
      stroke: #f00;
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke-opacity: 0.75;
      mix-blend-mode: difference;
    }

    &:hover {
      pointer-events: all;

      .inpaint-handle {
        stroke: #000;
      }
    }

    .inpaint-handle {
      opacity: 0;
    }

    &.selected .inpaint-handle,
    &:hover .inpaint-handle {
      opacity: 1;
    }

    .inpaint-handle {
      fill: none;
      opacity: 0.25;
      stroke: #000;
      pointer-events: all;
    }
  }
}

.pan-editor-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;

  // SVG is overflow: hidden by default.  Set the handle to overflow: visible, so it can
  // be seen if it's offscreen.  It still won't be visible if cropping is active since the
  // crop will cut it off, but that's hard to fix.
  .handle {
    overflow: visible;
  }

  .pan-editor-crop-region {
    width: 100%;
    height: 100%;
    position: relative;
  }

  .monitor-preview-box {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transform-origin: 0 0;

    > .box {
      // A large box shadow to dim the image:
      box-shadow: 0px 0px 0px 100000px #00000080;
      outline: 1px dashed #fff;
      width: 100%;
      height: 100%;
    }
  }
}

.ranking-data-source {
  .date-row {
    // The date field is fixed-width, since it's filled in from the API response.  This
    // prevents it from changing size as we load and moving other buttons around.
    .nav-today {
      display: inline-flex;
      justify-content: center;
      margin: 0 0.25em;
      min-width: 5em;
    }
  }
}

.tag-search-with-related-tags {
  display: flex;
  align-items: center;
  flex-wrap: wrap;

  .search-box {
    flex: 1;
  }
}

.slider {
  display: flex;
  align-items: center;

  // To position the thumb:
  position: relative;
  min-width: 4em;
  cursor: pointer;

  // This is set by the widget.
  --fill: 75%;

  // These are in px and not em to guarantee an even number of pixels for centering.
  --track-height: 8px;
  --thumb-height: 24px;

  --on-color: #07f;
  --off-color: #fff;

  // We can be made taller and our touch zone will expand, but make sure we're at least as tall as
  // the thumb.
  min-height: var(--thumb-height);

  // Make room for the thumbs to overlap the edges.
  margin: 0 calc(var(--thumb-height) / 2);

  @include hover_or_active {
    --on-color: #0af;
  }

  .track-left {
    width: var(--fill);
    height: var(--track-height);
    border-radius: var(--border-radius-large);
    background-color: var(--on-color);
  }

  .track-right {
    flex: 1;
    height: var(--track-height);
    border-radius: var(--border-radius-large);
    background-color: var(--off-color);
  }

  .thumb {
    height: var(--thumb-height);
    aspect-ratio: 1;
    background-color: var(--on-color);
    position: absolute;
    left: var(--fill);
    translate: -50% 0;
    border-radius: 100%;
  }
}

.menu-dropdown-button {
  // Disable the background color on the box link used as the dropdown button.
  --box-link-hover-color: transparent;
  --box-link-selected-color: transparent;
  --box-link-selected-hover-color: transparent;
}

.menu-slider .slider {
  flex: 1;
}
